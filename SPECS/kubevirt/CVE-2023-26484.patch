From 3b2720a71bcd8b5c0904b892757d35b9e82ccb51 Mon Sep 17 00:00:00 2001
From: Ram Lavi <ralavi@redhat.com>
Date: Mon, 20 May 2024 12:42:09 +0300
Subject: [PATCH 1/4] virt-operator/generate: Add node-restriction policy

In order to restrict node patch of non-kubevirt labels and annotations,
Introducing new validatingAdmissionPolicy and
validatingAdmissionPolicyBinding objects that target the virt-handler
user.
non-kubevirt labels and annotations is defined by labels and annotations
that contain "kubevirt.io" string, or "cpu-manager" label which is the
exception.
In future commits these objects will be deployed by virt-operator.

Signed-off-by: Ram Lavi <ralavi@redhat.com>
---
 .../resource/generate/components/BUILD.bazel  |   3 +
 .../components/validatingadmissionpolicy.go   | 179 ++++++++++++++++++
 .../validatingadmissionpolicy_test.go         |  53 ++++++
 3 files changed, 235 insertions(+)
 create mode 100644 pkg/virt-operator/resource/generate/components/validatingadmissionpolicy.go
 create mode 100644 pkg/virt-operator/resource/generate/components/validatingadmissionpolicy_test.go

diff --git a/pkg/virt-operator/resource/generate/components/BUILD.bazel b/pkg/virt-operator/resource/generate/components/BUILD.bazel
index 3f84ed1cd8e1..69b769a2c1bb 100644
--- a/pkg/virt-operator/resource/generate/components/BUILD.bazel
+++ b/pkg/virt-operator/resource/generate/components/BUILD.bazel
@@ -13,6 +13,7 @@ go_library(
         "routes.go",
         "scc.go",
         "secrets.go",
+        "validatingadmissionpolicy.go",
         "validations_generated.go",
         "webhooks.go",
     ],
@@ -26,6 +27,7 @@ go_library(
         "//pkg/certificates/bootstrap:go_default_library",
         "//pkg/certificates/triple:go_default_library",
         "//pkg/certificates/triple/cert:go_default_library",
+        "//pkg/pointer:go_default_library",
         "//pkg/virt-config:go_default_library",
         "//pkg/virt-operator/resource/generate/rbac:go_default_library",
         "//pkg/virt-operator/util:go_default_library",
@@ -75,6 +77,7 @@ go_test(
         "deployments_test.go",
         "scc_test.go",
         "secrets_test.go",
+        "validatingadmissionpolicy_test.go",
         "webhooks_test.go",
     ],
     embed = [":go_default_library"],
diff --git a/pkg/virt-operator/resource/generate/components/validatingadmissionpolicy.go b/pkg/virt-operator/resource/generate/components/validatingadmissionpolicy.go
new file mode 100644
index 000000000000..5fefec230489
--- /dev/null
+++ b/pkg/virt-operator/resource/generate/components/validatingadmissionpolicy.go
@@ -0,0 +1,179 @@
+/*
+ * This file is part of the KubeVirt project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * Copyright The KubeVirt Authors.
+ *
+ */
+
+package components
+
+import (
+	"fmt"
+
+	admissionregistrationv1 "k8s.io/api/admissionregistration/v1"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+
+	v1 "kubevirt.io/api/core/v1"
+
+	"kubevirt.io/kubevirt/pkg/pointer"
+)
+
+const (
+	validatingAdmissionPolicyBindingName = "kubevirt-node-restriction-binding"
+	validatingAdmissionPolicyName        = "kubevirt-node-restriction-policy"
+	nodeRestrictionAppLabelValue         = "kubevirt-node-restriction"
+
+	NodeRestrictionErrModifySpec           = "this user cannot modify spec of node"
+	NodeRestrictionErrChangeMetadataFields = "this user can only change allowed metadata fields"
+	NodeRestrictionErrAddDeleteLabels      = "this user cannot add/delete non kubevirt-owned labels"
+	NodeRestrictionErrUpdateLabels         = "this user cannot update non kubevirt-owned labels"
+	NodeRestrictionErrAddDeleteAnnotations = "this user cannot add/delete non kubevirt-owned annotations"
+	NodeRestrictionErrUpdateAnnotations    = "this user cannot update non kubevirt-owned annotations"
+)
+
+func NewHandlerV1ValidatingAdmissionPolicyBinding() *admissionregistrationv1.ValidatingAdmissionPolicyBinding {
+	return &admissionregistrationv1.ValidatingAdmissionPolicyBinding{
+		TypeMeta: metav1.TypeMeta{
+			APIVersion: "v1",
+			Kind:       "ValidatingAdmissionPolicyBinding",
+		},
+		ObjectMeta: metav1.ObjectMeta{
+			Name: validatingAdmissionPolicyBindingName,
+			Labels: map[string]string{
+				v1.AppLabel:       nodeRestrictionAppLabelValue,
+				v1.ManagedByLabel: v1.ManagedByLabelOperatorValue,
+			},
+		},
+		Spec: admissionregistrationv1.ValidatingAdmissionPolicyBindingSpec{
+			PolicyName: validatingAdmissionPolicyName,
+			ValidationActions: []admissionregistrationv1.ValidationAction{
+				admissionregistrationv1.Deny,
+			},
+			MatchResources: &admissionregistrationv1.MatchResources{
+				ResourceRules: []admissionregistrationv1.NamedRuleWithOperations{
+					{
+						RuleWithOperations: admissionregistrationv1.RuleWithOperations{
+							Operations: []admissionregistrationv1.OperationType{
+								admissionregistrationv1.OperationAll,
+							},
+							Rule: admissionregistrationv1.Rule{
+								APIGroups:   []string{""},
+								APIVersions: []string{"*"},
+								Resources:   []string{"nodes"},
+							},
+						},
+					},
+				},
+			},
+		},
+	}
+}
+
+func NewHandlerV1ValidatingAdmissionPolicy(virtHandlerServiceAccount string) *admissionregistrationv1.ValidatingAdmissionPolicy {
+	return &admissionregistrationv1.ValidatingAdmissionPolicy{
+		TypeMeta: metav1.TypeMeta{
+			APIVersion: "v1",
+			Kind:       "ValidatingAdmissionPolicy",
+		},
+		ObjectMeta: metav1.ObjectMeta{
+			Name: validatingAdmissionPolicyName,
+		},
+		Spec: admissionregistrationv1.ValidatingAdmissionPolicySpec{
+			FailurePolicy: pointer.P(admissionregistrationv1.Fail),
+			MatchConstraints: &admissionregistrationv1.MatchResources{
+				ResourceRules: []admissionregistrationv1.NamedRuleWithOperations{
+					{
+						RuleWithOperations: admissionregistrationv1.RuleWithOperations{
+							Operations: []admissionregistrationv1.OperationType{
+								admissionregistrationv1.Update,
+							},
+							Rule: admissionregistrationv1.Rule{
+								APIGroups:   []string{""},
+								APIVersions: []string{"*"},
+								Resources:   []string{"nodes"},
+							},
+						},
+					},
+				},
+			},
+			MatchConditions: []admissionregistrationv1.MatchCondition{
+				{
+					Name:       "virt-handler-user-only",
+					Expression: fmt.Sprintf("request.userInfo.username == %q", virtHandlerServiceAccount),
+				},
+			},
+			Variables: []admissionregistrationv1.Variable{
+				{
+					Name:       "oldNonKubevirtLabels",
+					Expression: `oldObject.metadata.labels.filter(k, !k.contains("kubevirt.io") && k != "cpumanager")`,
+				},
+				{
+					Name:       "oldLabels",
+					Expression: "oldObject.metadata.labels",
+				},
+				{
+					Name:       "newNonKubevirtLabels",
+					Expression: `object.metadata.labels.filter(k, !k.contains("kubevirt.io") && k != "cpumanager")`,
+				},
+				{
+					Name:       "newLabels",
+					Expression: "object.metadata.labels",
+				},
+				{
+					Name:       "oldNonKubevirtAnnotations",
+					Expression: `oldObject.metadata.annotations.filter(k, !k.contains("kubevirt.io"))`,
+				},
+				{
+					Name:       "newNonKubevirtAnnotations",
+					Expression: `object.metadata.annotations.filter(k, !k.contains("kubevirt.io"))`,
+				},
+				{
+					Name:       "oldAnnotations",
+					Expression: "oldObject.metadata.annotations",
+				},
+				{
+					Name:       "newAnnotations",
+					Expression: "object.metadata.annotations",
+				},
+			},
+			Validations: []admissionregistrationv1.Validation{
+				{
+					Expression: "object.spec == oldObject.spec",
+					Message:    NodeRestrictionErrModifySpec,
+				},
+				{
+					Expression: `oldObject.metadata.filter(k, k != "labels" && k != "annotations" && k != "managedFields" && k != "resourceVersion").all(k, k in object.metadata) && object.metadata.filter(k, k != "labels" && k != "annotations" && k != "managedFields" && k != "resourceVersion").all(k, k in oldObject.metadata && oldObject.metadata[k] == object.metadata[k])`,
+					Message:    NodeRestrictionErrChangeMetadataFields,
+				},
+				{
+					Expression: `size(variables.newNonKubevirtLabels) == size(variables.oldNonKubevirtLabels)`,
+					Message:    NodeRestrictionErrAddDeleteLabels,
+				},
+				{
+					Expression: `variables.newNonKubevirtLabels.all(k, k in variables.oldNonKubevirtLabels && variables.newLabels[k] == variables.oldLabels[k])`,
+					Message:    NodeRestrictionErrUpdateLabels,
+				},
+				{
+					Expression: `size(variables.newNonKubevirtAnnotations) == size(variables.oldNonKubevirtAnnotations)`,
+					Message:    NodeRestrictionErrAddDeleteAnnotations,
+				},
+				{
+					Expression: `variables.newNonKubevirtAnnotations.all(k, k in variables.oldNonKubevirtAnnotations && variables.newAnnotations[k] == variables.oldAnnotations[k])`,
+					Message:    NodeRestrictionErrUpdateAnnotations,
+				},
+			},
+		},
+	}
+}
diff --git a/pkg/virt-operator/resource/generate/components/validatingadmissionpolicy_test.go b/pkg/virt-operator/resource/generate/components/validatingadmissionpolicy_test.go
new file mode 100644
index 000000000000..39cb37d6f412
--- /dev/null
+++ b/pkg/virt-operator/resource/generate/components/validatingadmissionpolicy_test.go
@@ -0,0 +1,53 @@
+/*
+ * This file is part of the KubeVirt project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * Copyright The KubeVirt Authors.
+ *
+ */
+
+package components_test
+
+import (
+	"fmt"
+
+	. "github.com/onsi/ginkgo/v2"
+	. "github.com/onsi/gomega"
+
+	"kubevirt.io/kubevirt/pkg/virt-operator/resource/generate/components"
+)
+
+var _ = Describe("Validation Admission Policy", func() {
+	Context("ValidatingAdmissionPolicy", func() {
+		It("should generate the expected policy", func() {
+			const userName = "system:serviceaccount:kubevirt-ns:kubevirt-handler"
+			validatingAdmissionPolicy := components.NewHandlerV1ValidatingAdmissionPolicy(userName)
+
+			expectedMatchConditionExpression := fmt.Sprintf("request.userInfo.username == %q", userName)
+			Expect(validatingAdmissionPolicy.Spec.MatchConditions[0].Expression).To(Equal(expectedMatchConditionExpression))
+			Expect(validatingAdmissionPolicy.Kind).ToNot(BeEmpty())
+		})
+	})
+
+	Context("ValidatingAdmissionPolicyBinding", func() {
+		It("should generate the expected policy binding", func() {
+			const userName = "system:serviceaccount:kubevirt-ns:kubevirt-handler"
+			validatingAdmissionPolicy := components.NewHandlerV1ValidatingAdmissionPolicy(userName)
+			validatingAdmissionPolicyBinding := components.NewHandlerV1ValidatingAdmissionPolicyBinding()
+
+			Expect(validatingAdmissionPolicyBinding.Spec.PolicyName).To(Equal(validatingAdmissionPolicy.Name))
+			Expect(validatingAdmissionPolicyBinding.Kind).ToNot(BeEmpty())
+		})
+	})
+})

From 7c596e5c2aa4848617a8c90a223b11afaa7f58c3 Mon Sep 17 00:00:00 2001
From: Ram Lavi <ralavi@redhat.com>
Date: Mon, 27 May 2024 10:42:35 +0300
Subject: [PATCH 2/4] virt-operator/rbac: Add validating policy and binding
 permissions

This commit grants virt-operatord permission to "get", "list", "watch",
"create", "delete", "update" and "patch" validatingAdmission policy and
binding objects.

Signed-off-by: Ram Lavi <ralavi@redhat.com>
---
 manifests/generated/operator-csv.yaml.in                    | 2 ++
 manifests/generated/rbac-operator.authorization.k8s.yaml.in | 2 ++
 pkg/virt-operator/resource/generate/rbac/operator.go        | 2 ++
 3 files changed, 6 insertions(+)

diff --git a/manifests/generated/operator-csv.yaml.in b/manifests/generated/operator-csv.yaml.in
index 8001137af878..400d11802454 100644
--- a/manifests/generated/operator-csv.yaml.in
+++ b/manifests/generated/operator-csv.yaml.in
@@ -288,6 +288,8 @@ spec:
           resources:
           - validatingwebhookconfigurations
           - mutatingwebhookconfigurations
+          - validatingadmissionpolicybindings
+          - validatingadmissionpolicies
           verbs:
           - get
           - list
diff --git a/manifests/generated/rbac-operator.authorization.k8s.yaml.in b/manifests/generated/rbac-operator.authorization.k8s.yaml.in
index c0e76e8e6235..10dbb92269be 100644
--- a/manifests/generated/rbac-operator.authorization.k8s.yaml.in
+++ b/manifests/generated/rbac-operator.authorization.k8s.yaml.in
@@ -290,6 +290,8 @@ rules:
   resources:
   - validatingwebhookconfigurations
   - mutatingwebhookconfigurations
+  - validatingadmissionpolicybindings
+  - validatingadmissionpolicies
   verbs:
   - get
   - list
diff --git a/pkg/virt-operator/resource/generate/rbac/operator.go b/pkg/virt-operator/resource/generate/rbac/operator.go
index b90a5fae8559..160083ac5be1 100644
--- a/pkg/virt-operator/resource/generate/rbac/operator.go
+++ b/pkg/virt-operator/resource/generate/rbac/operator.go
@@ -271,6 +271,8 @@ func NewOperatorClusterRole() *rbacv1.ClusterRole {
 				Resources: []string{
 					"validatingwebhookconfigurations",
 					"mutatingwebhookconfigurations",
+					"validatingadmissionpolicybindings",
+					"validatingadmissionpolicies",
 				},
 				Verbs: []string{
 					"get", "list", "watch", "create", "delete", "update", "patch",

From 001e8d9f0f8a7c70e49e7522986c9b3589fe5ff3 Mon Sep 17 00:00:00 2001
From: Ram Lavi <ralavi@redhat.com>
Date: Mon, 27 May 2024 10:46:25 +0300
Subject: [PATCH 3/4] virt-operator: Deploy node-restriction policy

virt-operator will deploy the validatingAdmission policy
and binding objects implementing the node restriction for
virt-handler.

Signed-off-by: Ram Lavi <ralavi@redhat.com>
---
 pkg/controller/virtinformers.go               |  50 ++++++
 pkg/virt-operator/application.go              |  30 ++++
 pkg/virt-operator/kubevirt.go                 |  76 ++++++---
 pkg/virt-operator/kubevirt_test.go            | 105 +++++++++---
 .../resource/apply/admissionregistration.go   | 158 +++++++++++++++++
 pkg/virt-operator/resource/apply/delete.go    |  36 ++++
 pkg/virt-operator/resource/apply/reconcile.go |  61 ++++++-
 .../resource/generate/install/strategy.go     |  67 ++++++--
 pkg/virt-operator/util/BUILD.bazel            |   1 +
 pkg/virt-operator/util/client.go              |  43 +++++
 pkg/virt-operator/util/types.go               | 160 ++++++++++--------
 11 files changed, 656 insertions(+), 131 deletions(-)

diff --git a/pkg/controller/virtinformers.go b/pkg/controller/virtinformers.go
index 49c3ab3e93ed..1441b0788318 100644
--- a/pkg/controller/virtinformers.go
+++ b/pkg/controller/virtinformers.go
@@ -288,6 +288,18 @@ type KubeInformerFactory interface {
 	// Fake ServiceMonitor informer used when Prometheus is not installed
 	DummyOperatorServiceMonitor() cache.SharedIndexInformer
 
+	// ValidatingAdmissionPolicyBinding created/managed by virt operator
+	OperatorValidatingAdmissionPolicyBinding() cache.SharedIndexInformer
+
+	// Fake OperatorValidatingAdmissionPolicyBinding informer used when ValidatingAdmissionPolicyBinding is not installed
+	DummyOperatorValidatingAdmissionPolicyBinding() cache.SharedIndexInformer
+
+	// ValidatingAdmissionPolicies created/managed by virt operator
+	OperatorValidatingAdmissionPolicy() cache.SharedIndexInformer
+
+	// Fake OperatorValidatingAdmissionPolicy informer used when ValidatingAdmissionPolicy is not installed
+	DummyOperatorValidatingAdmissionPolicy() cache.SharedIndexInformer
+
 	// The namespace where kubevirt is deployed in
 	Namespace() cache.SharedIndexInformer
 
@@ -1283,6 +1295,44 @@ func (f *kubeInformerFactory) DummyOperatorServiceMonitor() cache.SharedIndexInf
 	})
 }
 
+func (f *kubeInformerFactory) OperatorValidatingAdmissionPolicyBinding() cache.SharedIndexInformer {
+	return f.getInformer("operatorValidatingAdmissionPolicyBindingInformer", func() cache.SharedIndexInformer {
+		labelSelector, err := labels.Parse(OperatorLabel)
+		if err != nil {
+			panic(err)
+		}
+
+		lw := NewListWatchFromClient(f.clientSet.AdmissionregistrationV1().RESTClient(), "validatingadmissionpolicybindings", k8sv1.NamespaceAll, fields.Everything(), labelSelector)
+		return cache.NewSharedIndexInformer(lw, &admissionregistrationv1.ValidatingAdmissionPolicyBinding{}, f.defaultResync, cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc})
+	})
+}
+
+func (f *kubeInformerFactory) DummyOperatorValidatingAdmissionPolicyBinding() cache.SharedIndexInformer {
+	return f.getInformer("FakeOperatorValidatingAdmissionPolicyBindingInformer", func() cache.SharedIndexInformer {
+		informer, _ := testutils.NewFakeInformerFor(&admissionregistrationv1.ValidatingAdmissionPolicyBinding{})
+		return informer
+	})
+}
+
+func (f *kubeInformerFactory) OperatorValidatingAdmissionPolicy() cache.SharedIndexInformer {
+	return f.getInformer("operatorValidatingAdmissionPolicyInformer", func() cache.SharedIndexInformer {
+		labelSelector, err := labels.Parse(OperatorLabel)
+		if err != nil {
+			panic(err)
+		}
+
+		lw := NewListWatchFromClient(f.clientSet.AdmissionregistrationV1().RESTClient(), "validatingadmissionpolicies", k8sv1.NamespaceAll, fields.Everything(), labelSelector)
+		return cache.NewSharedIndexInformer(lw, &admissionregistrationv1.ValidatingAdmissionPolicy{}, f.defaultResync, cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc})
+	})
+}
+
+func (f *kubeInformerFactory) DummyOperatorValidatingAdmissionPolicy() cache.SharedIndexInformer {
+	return f.getInformer("FakeOperatorValidatingAdmissionPolicyInformer", func() cache.SharedIndexInformer {
+		informer, _ := testutils.NewFakeInformerFor(&admissionregistrationv1.ValidatingAdmissionPolicy{})
+		return informer
+	})
+}
+
 func (f *kubeInformerFactory) K8SInformerFactory() informers.SharedInformerFactory {
 	return f.k8sInformers
 }
diff --git a/pkg/virt-operator/application.go b/pkg/virt-operator/application.go
index af994c4c797e..0a7830e6f766 100644
--- a/pkg/virt-operator/application.go
+++ b/pkg/virt-operator/application.go
@@ -270,6 +270,36 @@ func Execute() {
 		app.stores.PrometheusRuleCache = app.informerFactory.DummyOperatorPrometheusRule().GetStore()
 	}
 
+	validatingAdmissionPolicyBindingEnabled, err := util.IsValidatingAdmissionPolicyBindingEnabled(app.clientSet)
+	if err != nil {
+		golog.Fatalf("Error checking for ValidatingAdmissionPolicyBinding: %v", err)
+	}
+	if validatingAdmissionPolicyBindingEnabled {
+		log.Log.Info("validatingAdmissionPolicyBindingEnabled is defined")
+		app.informers.ValidatingAdmissionPolicyBinding = app.informerFactory.OperatorValidatingAdmissionPolicyBinding()
+		app.stores.ValidatingAdmissionPolicyBindingCache = app.informerFactory.OperatorValidatingAdmissionPolicyBinding().GetStore()
+		app.stores.ValidatingAdmissionPolicyBindingEnabled = true
+	} else {
+		log.Log.Info("validatingAdmissionPolicyBindingEnabled is not defined")
+		app.informers.ValidatingAdmissionPolicyBinding = app.informerFactory.DummyOperatorValidatingAdmissionPolicyBinding()
+		app.stores.ValidatingAdmissionPolicyBindingCache = app.informerFactory.DummyOperatorValidatingAdmissionPolicyBinding().GetStore()
+	}
+
+	validatingAdmissionPolicyEnabled, err := util.IsValidatingAdmissionPolicyEnabled(app.clientSet)
+	if err != nil {
+		golog.Fatalf("Error checking for ValidatingAdmissionPolicy: %v", err)
+	}
+	if validatingAdmissionPolicyEnabled {
+		log.Log.Info("validatingAdmissionPolicyEnabled is defined")
+		app.informers.ValidatingAdmissionPolicy = app.informerFactory.OperatorValidatingAdmissionPolicy()
+		app.stores.ValidatingAdmissionPolicyCache = app.informerFactory.OperatorValidatingAdmissionPolicy().GetStore()
+		app.stores.ValidatingAdmissionPolicyEnabled = true
+	} else {
+		log.Log.Info("validatingAdmissionPolicyEnabled is not defined")
+		app.informers.ValidatingAdmissionPolicy = app.informerFactory.DummyOperatorValidatingAdmissionPolicy()
+		app.stores.ValidatingAdmissionPolicyCache = app.informerFactory.DummyOperatorValidatingAdmissionPolicy().GetStore()
+	}
+
 	app.prepareCertManagers()
 
 	app.kubeVirtRecorder = app.getNewRecorder(k8sv1.NamespaceAll, VirtOperator)
diff --git a/pkg/virt-operator/kubevirt.go b/pkg/virt-operator/kubevirt.go
index 054499ee3cca..fdd7095a6463 100644
--- a/pkg/virt-operator/kubevirt.go
+++ b/pkg/virt-operator/kubevirt.go
@@ -101,27 +101,29 @@ func NewKubeVirtController(
 		stores:           stores,
 		informers:        informers,
 		kubeVirtExpectations: util.Expectations{
-			ServiceAccount:           controller.NewUIDTrackingControllerExpectations(controller.NewControllerExpectationsWithName("ServiceAccount")),
-			ClusterRole:              controller.NewUIDTrackingControllerExpectations(controller.NewControllerExpectationsWithName("ClusterRole")),
-			ClusterRoleBinding:       controller.NewUIDTrackingControllerExpectations(controller.NewControllerExpectationsWithName("ClusterRoleBinding")),
-			Role:                     controller.NewUIDTrackingControllerExpectations(controller.NewControllerExpectationsWithName("Role")),
-			RoleBinding:              controller.NewUIDTrackingControllerExpectations(controller.NewControllerExpectationsWithName("RoleBinding")),
-			Crd:                      controller.NewUIDTrackingControllerExpectations(controller.NewControllerExpectationsWithName("Crd")),
-			Service:                  controller.NewUIDTrackingControllerExpectations(controller.NewControllerExpectationsWithName("Service")),
-			Deployment:               controller.NewUIDTrackingControllerExpectations(controller.NewControllerExpectationsWithName("Deployment")),
-			DaemonSet:                controller.NewUIDTrackingControllerExpectations(controller.NewControllerExpectationsWithName("DaemonSet")),
-			ValidationWebhook:        controller.NewUIDTrackingControllerExpectations(controller.NewControllerExpectationsWithName("ValidationWebhook")),
-			MutatingWebhook:          controller.NewUIDTrackingControllerExpectations(controller.NewControllerExpectationsWithName("MutatingWebhook")),
-			APIService:               controller.NewUIDTrackingControllerExpectations(controller.NewControllerExpectationsWithName("APIService")),
-			SCC:                      controller.NewUIDTrackingControllerExpectations(controller.NewControllerExpectationsWithName("SCC")),
-			Route:                    controller.NewUIDTrackingControllerExpectations(controller.NewControllerExpectationsWithName("Route")),
-			InstallStrategyConfigMap: controller.NewUIDTrackingControllerExpectations(controller.NewControllerExpectationsWithName("InstallStrategyConfigMap")),
-			InstallStrategyJob:       controller.NewUIDTrackingControllerExpectations(controller.NewControllerExpectationsWithName("Jobs")),
-			PodDisruptionBudget:      controller.NewUIDTrackingControllerExpectations(controller.NewControllerExpectationsWithName("PodDisruptionBudgets")),
-			ServiceMonitor:           controller.NewUIDTrackingControllerExpectations(controller.NewControllerExpectationsWithName("ServiceMonitor")),
-			PrometheusRule:           controller.NewUIDTrackingControllerExpectations(controller.NewControllerExpectationsWithName("PrometheusRule")),
-			Secrets:                  controller.NewUIDTrackingControllerExpectations(controller.NewControllerExpectationsWithName("Secret")),
-			ConfigMap:                controller.NewUIDTrackingControllerExpectations(controller.NewControllerExpectationsWithName("ConfigMap")),
+			ServiceAccount:                   controller.NewUIDTrackingControllerExpectations(controller.NewControllerExpectationsWithName("ServiceAccount")),
+			ClusterRole:                      controller.NewUIDTrackingControllerExpectations(controller.NewControllerExpectationsWithName("ClusterRole")),
+			ClusterRoleBinding:               controller.NewUIDTrackingControllerExpectations(controller.NewControllerExpectationsWithName("ClusterRoleBinding")),
+			Role:                             controller.NewUIDTrackingControllerExpectations(controller.NewControllerExpectationsWithName("Role")),
+			RoleBinding:                      controller.NewUIDTrackingControllerExpectations(controller.NewControllerExpectationsWithName("RoleBinding")),
+			Crd:                              controller.NewUIDTrackingControllerExpectations(controller.NewControllerExpectationsWithName("Crd")),
+			Service:                          controller.NewUIDTrackingControllerExpectations(controller.NewControllerExpectationsWithName("Service")),
+			Deployment:                       controller.NewUIDTrackingControllerExpectations(controller.NewControllerExpectationsWithName("Deployment")),
+			DaemonSet:                        controller.NewUIDTrackingControllerExpectations(controller.NewControllerExpectationsWithName("DaemonSet")),
+			ValidationWebhook:                controller.NewUIDTrackingControllerExpectations(controller.NewControllerExpectationsWithName("ValidationWebhook")),
+			MutatingWebhook:                  controller.NewUIDTrackingControllerExpectations(controller.NewControllerExpectationsWithName("MutatingWebhook")),
+			APIService:                       controller.NewUIDTrackingControllerExpectations(controller.NewControllerExpectationsWithName("APIService")),
+			SCC:                              controller.NewUIDTrackingControllerExpectations(controller.NewControllerExpectationsWithName("SCC")),
+			Route:                            controller.NewUIDTrackingControllerExpectations(controller.NewControllerExpectationsWithName("Route")),
+			InstallStrategyConfigMap:         controller.NewUIDTrackingControllerExpectations(controller.NewControllerExpectationsWithName("InstallStrategyConfigMap")),
+			InstallStrategyJob:               controller.NewUIDTrackingControllerExpectations(controller.NewControllerExpectationsWithName("Jobs")),
+			PodDisruptionBudget:              controller.NewUIDTrackingControllerExpectations(controller.NewControllerExpectationsWithName("PodDisruptionBudgets")),
+			ServiceMonitor:                   controller.NewUIDTrackingControllerExpectations(controller.NewControllerExpectationsWithName("ServiceMonitor")),
+			PrometheusRule:                   controller.NewUIDTrackingControllerExpectations(controller.NewControllerExpectationsWithName("PrometheusRule")),
+			Secrets:                          controller.NewUIDTrackingControllerExpectations(controller.NewControllerExpectationsWithName("Secret")),
+			ConfigMap:                        controller.NewUIDTrackingControllerExpectations(controller.NewControllerExpectationsWithName("ConfigMap")),
+			ValidatingAdmissionPolicyBinding: controller.NewUIDTrackingControllerExpectations(controller.NewControllerExpectationsWithName("ValidatingAdmissionPolicyBinding")),
+			ValidatingAdmissionPolicy:        controller.NewUIDTrackingControllerExpectations(controller.NewControllerExpectationsWithName("ValidatingAdmissionPolicy")),
 		},
 		installStrategyMap: make(map[string]*install.Strategy),
 		operatorNamespace:  operatorNamespace,
@@ -409,6 +409,30 @@ func NewKubeVirtController(
 		},
 	})
 
+	c.informers.ValidatingAdmissionPolicyBinding.AddEventHandler(cache.ResourceEventHandlerFuncs{
+		AddFunc: func(obj interface{}) {
+			c.genericAddHandler(obj, c.kubeVirtExpectations.ValidatingAdmissionPolicyBinding)
+		},
+		DeleteFunc: func(obj interface{}) {
+			c.genericDeleteHandler(obj, c.kubeVirtExpectations.ValidatingAdmissionPolicyBinding)
+		},
+		UpdateFunc: func(oldObj, newObj interface{}) {
+			c.genericUpdateHandler(oldObj, newObj, c.kubeVirtExpectations.ValidatingAdmissionPolicyBinding)
+		},
+	})
+
+	c.informers.ValidatingAdmissionPolicy.AddEventHandler(cache.ResourceEventHandlerFuncs{
+		AddFunc: func(obj interface{}) {
+			c.genericAddHandler(obj, c.kubeVirtExpectations.ValidatingAdmissionPolicy)
+		},
+		DeleteFunc: func(obj interface{}) {
+			c.genericDeleteHandler(obj, c.kubeVirtExpectations.ValidatingAdmissionPolicy)
+		},
+		UpdateFunc: func(oldObj, newObj interface{}) {
+			c.genericUpdateHandler(oldObj, newObj, c.kubeVirtExpectations.ValidatingAdmissionPolicy)
+		},
+	})
+
 	return &c
 }
 
@@ -652,6 +684,8 @@ func (c *KubeVirtController) Run(threadiness int, stopCh <-chan struct{}) {
 	cache.WaitForCacheSync(stopCh, c.informers.PrometheusRule.HasSynced)
 	cache.WaitForCacheSync(stopCh, c.informers.Secrets.HasSynced)
 	cache.WaitForCacheSync(stopCh, c.informers.ConfigMap.HasSynced)
+	cache.WaitForCacheSync(stopCh, c.informers.ValidatingAdmissionPolicyBinding.HasSynced)
+	cache.WaitForCacheSync(stopCh, c.informers.ValidatingAdmissionPolicy.HasSynced)
 
 	// Start the actual work
 	for i := 0; i < threadiness; i++ {
diff --git a/pkg/virt-operator/kubevirt_test.go b/pkg/virt-operator/kubevirt_test.go
index f65a241c5d47..af87e2fe66ba 100644
--- a/pkg/virt-operator/kubevirt_test.go
+++ b/pkg/virt-operator/kubevirt_test.go
@@ -100,29 +100,31 @@ type KubeVirtTestData struct {
 	kvInformer       cache.SharedIndexInformer
 	apiServiceClient *install.MockAPIServiceInterface
 
-	serviceAccountSource           *framework.FakeControllerSource
-	clusterRoleSource              *framework.FakeControllerSource
-	clusterRoleBindingSource       *framework.FakeControllerSource
-	roleSource                     *framework.FakeControllerSource
-	roleBindingSource              *framework.FakeControllerSource
-	crdSource                      *framework.FakeControllerSource
-	serviceSource                  *framework.FakeControllerSource
-	deploymentSource               *framework.FakeControllerSource
-	daemonSetSource                *framework.FakeControllerSource
-	validatingWebhookSource        *framework.FakeControllerSource
-	mutatingWebhookSource          *framework.FakeControllerSource
-	apiserviceSource               *framework.FakeControllerSource
-	sccSource                      *framework.FakeControllerSource
-	routeSource                    *framework.FakeControllerSource
-	installStrategyConfigMapSource *framework.FakeControllerSource
-	installStrategyJobSource       *framework.FakeControllerSource
-	infrastructurePodSource        *framework.FakeControllerSource
-	podDisruptionBudgetSource      *framework.FakeControllerSource
-	serviceMonitorSource           *framework.FakeControllerSource
-	namespaceSource                *framework.FakeControllerSource
-	prometheusRuleSource           *framework.FakeControllerSource
-	secretsSource                  *framework.FakeControllerSource
-	configMapSource                *framework.FakeControllerSource
+	serviceAccountSource                   *framework.FakeControllerSource
+	clusterRoleSource                      *framework.FakeControllerSource
+	clusterRoleBindingSource               *framework.FakeControllerSource
+	roleSource                             *framework.FakeControllerSource
+	roleBindingSource                      *framework.FakeControllerSource
+	crdSource                              *framework.FakeControllerSource
+	serviceSource                          *framework.FakeControllerSource
+	deploymentSource                       *framework.FakeControllerSource
+	daemonSetSource                        *framework.FakeControllerSource
+	validatingWebhookSource                *framework.FakeControllerSource
+	mutatingWebhookSource                  *framework.FakeControllerSource
+	apiserviceSource                       *framework.FakeControllerSource
+	sccSource                              *framework.FakeControllerSource
+	routeSource                            *framework.FakeControllerSource
+	installStrategyConfigMapSource         *framework.FakeControllerSource
+	installStrategyJobSource               *framework.FakeControllerSource
+	infrastructurePodSource                *framework.FakeControllerSource
+	podDisruptionBudgetSource              *framework.FakeControllerSource
+	serviceMonitorSource                   *framework.FakeControllerSource
+	namespaceSource                        *framework.FakeControllerSource
+	prometheusRuleSource                   *framework.FakeControllerSource
+	secretsSource                          *framework.FakeControllerSource
+	configMapSource                        *framework.FakeControllerSource
+	ValidatingAdmissionPolicyBindingSource *framework.FakeControllerSource
+	ValidatingAdmissionPolicySource        *framework.FakeControllerSource
 
 	stop       chan struct{}
 	controller *KubeVirtController
@@ -259,6 +261,13 @@ func (k *KubeVirtTestData) BeforeTest() {
 	k.informers.ConfigMap, k.configMapSource = testutils.NewFakeInformerFor(&k8sv1.ConfigMap{})
 	k.stores.ConfigMapCache = k.informers.ConfigMap.GetStore()
 
+	k.informers.ValidatingAdmissionPolicyBinding, k.ValidatingAdmissionPolicyBindingSource = testutils.NewFakeInformerFor(&admissionregistrationv1.ValidatingAdmissionPolicyBinding{})
+	k.stores.ValidatingAdmissionPolicyBindingCache = k.informers.ValidatingAdmissionPolicyBinding.GetStore()
+	k.stores.ValidatingAdmissionPolicyBindingEnabled = true
+	k.informers.ValidatingAdmissionPolicy, k.ValidatingAdmissionPolicySource = testutils.NewFakeInformerFor(&admissionregistrationv1.ValidatingAdmissionPolicy{})
+	k.stores.ValidatingAdmissionPolicyCache = k.informers.ValidatingAdmissionPolicy.GetStore()
+	k.stores.ValidatingAdmissionPolicyEnabled = true
+
 	k.controller = NewKubeVirtController(k.virtClient, k.apiServiceClient, k.kvInformer, k.recorder, k.stores, k.informers, NAMESPACE)
 	k.controller.delayedQueueAdder = func(key interface{}, queue workqueue.RateLimitingInterface) {
 		// no delay to speed up tests
@@ -309,6 +318,14 @@ func (k *KubeVirtTestData) BeforeTest() {
 		if action.GetVerb() == "get" && action.GetResource().Resource == "mutatingwebhookconfigurations" {
 			return true, nil, errors.NewNotFound(schema.GroupResource{Group: "", Resource: "mutatingwebhookconfigurations"}, "whatever")
 		}
+		if action.GetVerb() == "create" && action.GetResource().Resource == "validatingadmissionpolicybindings" {
+			dummyValidatingAdmissionPolicyBinding := &admissionregistrationv1.ValidatingAdmissionPolicyBinding{}
+			return true, dummyValidatingAdmissionPolicyBinding, nil
+		}
+		if action.GetVerb() == "create" && action.GetResource().Resource == "validatingadmissionpolicies" {
+			dummyValidatingAdmissionPolicy := &admissionregistrationv1.ValidatingAdmissionPolicy{}
+			return true, dummyValidatingAdmissionPolicy, nil
+		}
 		if action.GetVerb() == "get" && action.GetResource().Resource == "serviceaccounts" {
 			return true, nil, errors.NewNotFound(schema.GroupResource{Group: "", Resource: "serviceaccounts"}, "whatever")
 		}
@@ -533,6 +550,10 @@ func (k *KubeVirtTestData) deleteResource(resource string, key string) {
 		k.deleteInstallStrategyJob(key)
 	case "configmaps":
 		k.deleteConfigMap(key)
+	case "validatingadmissionpolicybindings":
+		k.deleteValidatingAdmissionPolicyBinding(key)
+	case "validatingadmissionpolicies":
+		k.deleteValidatingAdmissionPolicy(key)
 	case "poddisruptionbudgets":
 		k.deletePodDisruptionBudget(key)
 	case "secrets":
@@ -686,6 +707,24 @@ func (k *KubeVirtTestData) deleteConfigMap(key string) {
 	k.mockQueue.Wait()
 }
 
+func (k *KubeVirtTestData) deleteValidatingAdmissionPolicyBinding(key string) {
+	k.mockQueue.ExpectAdds(1)
+	if obj, exists, _ := k.informers.ValidatingAdmissionPolicyBinding.GetStore().GetByKey(key); exists {
+		validatingAdmissionPolicyBinding := obj.(*admissionregistrationv1.ValidatingAdmissionPolicyBinding)
+		k.ValidatingAdmissionPolicyBindingSource.Delete(validatingAdmissionPolicyBinding)
+	}
+	k.mockQueue.Wait()
+}
+
+func (k *KubeVirtTestData) deleteValidatingAdmissionPolicy(key string) {
+	k.mockQueue.ExpectAdds(1)
+	if obj, exists, _ := k.informers.ValidatingAdmissionPolicy.GetStore().GetByKey(key); exists {
+		validatingAdmissionPolicy := obj.(*admissionregistrationv1.ValidatingAdmissionPolicy)
+		k.ValidatingAdmissionPolicySource.Delete(validatingAdmissionPolicy)
+	}
+	k.mockQueue.Wait()
+}
+
 func (k *KubeVirtTestData) deleteSCC(key string) {
 	k.mockQueue.ExpectAdds(1)
 	if obj, exists, _ := k.informers.SCC.GetStore().GetByKey(key); exists {
@@ -863,6 +902,8 @@ func (k *KubeVirtTestData) shouldExpectCreations() {
 	k.secClient.Fake.PrependReactor("create", "securitycontextconstraints", genericCreateFunc)
 	k.promClient.Fake.PrependReactor("create", "servicemonitors", genericCreateFunc)
 	k.promClient.Fake.PrependReactor("create", "prometheusrules", genericCreateFunc)
+	k.promClient.Fake.PrependReactor("create", "validatingadmissionpolicybindings", genericCreateFunc)
+	k.promClient.Fake.PrependReactor("create", "validatingadmissionpolicies", genericCreateFunc)
 	k.apiServiceClient.EXPECT().Create(gomock.Any(), gomock.Any(), gomock.Any()).AnyTimes().Do(func(ctx context.Context, obj runtime.Object, opts metav1.CreateOptions) {
 		genericCreateFunc(&testing.CreateActionImpl{Object: obj})
 	})
@@ -945,6 +986,12 @@ func (k *KubeVirtTestData) addResource(obj runtime.Object, config *util.KubeVirt
 	case *routev1.Route:
 		injectMetadata(&obj.(*routev1.Route).ObjectMeta, config)
 		k.addRoute(resource)
+	case *admissionregistrationv1.ValidatingAdmissionPolicyBinding:
+		injectMetadata(&obj.(*admissionregistrationv1.ValidatingAdmissionPolicyBinding).ObjectMeta, config)
+		k.addValidatingAdmissionPolicyBinding(resource)
+	case *admissionregistrationv1.ValidatingAdmissionPolicy:
+		injectMetadata(&obj.(*admissionregistrationv1.ValidatingAdmissionPolicy).ObjectMeta, config)
+		k.addValidatingAdmissionPolicy(resource)
 	default:
 		Fail("unknown resource type")
 	}
@@ -1065,6 +1112,18 @@ func (k *KubeVirtTestData) addSecret(secret *k8sv1.Secret) {
 	k.mockQueue.Wait()
 }
 
+func (k *KubeVirtTestData) addValidatingAdmissionPolicyBinding(validatingAdmissionPolicyBinding *admissionregistrationv1.ValidatingAdmissionPolicyBinding) {
+	k.mockQueue.ExpectAdds(1)
+	k.ValidatingAdmissionPolicyBindingSource.Add(validatingAdmissionPolicyBinding)
+	k.mockQueue.Wait()
+}
+
+func (k *KubeVirtTestData) addValidatingAdmissionPolicy(validatingAdmissionPolicy *admissionregistrationv1.ValidatingAdmissionPolicy) {
+	k.mockQueue.ExpectAdds(1)
+	k.ValidatingAdmissionPolicySource.Add(validatingAdmissionPolicy)
+	k.mockQueue.Wait()
+}
+
 func (k *KubeVirtTestData) addConfigMap(configMap *k8sv1.ConfigMap) {
 	k.mockQueue.ExpectAdds(1)
 	if _, ok := configMap.Labels[v1.InstallStrategyLabel]; ok {
diff --git a/pkg/virt-operator/resource/apply/admissionregistration.go b/pkg/virt-operator/resource/apply/admissionregistration.go
index b8b02c8fdd41..c2ba98d196dd 100644
--- a/pkg/virt-operator/resource/apply/admissionregistration.go
+++ b/pkg/virt-operator/resource/apply/admissionregistration.go
@@ -9,6 +9,7 @@ import (
 	"github.com/openshift/library-go/pkg/operator/resource/resourcemerge"
 	admissionregistrationv1 "k8s.io/api/admissionregistration/v1"
 	admissionregistrationv1beta1 "k8s.io/api/admissionregistration/v1beta1"
+	"k8s.io/apimachinery/pkg/api/equality"
 	"k8s.io/apimachinery/pkg/api/errors"
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	"k8s.io/apimachinery/pkg/types"
@@ -353,3 +354,160 @@ func (r *Reconciler) createOrUpdateMutatingWebhookConfiguration(webhook *admissi
 
 	return nil
 }
+
+func generateValidatingAdmissionPolicyBindingPatch(
+	cachedValidatingAdmissionPolicyBinding *admissionregistrationv1.ValidatingAdmissionPolicyBinding,
+	validatingAdmissionPolicyBinding *admissionregistrationv1.ValidatingAdmissionPolicyBinding) ([]string, error) {
+
+	patchOps, err := getObjectMetaPatch(validatingAdmissionPolicyBinding.ObjectMeta, cachedValidatingAdmissionPolicyBinding.ObjectMeta)
+	if err != nil {
+		return nil, err
+	}
+
+	// If the Specs don't equal each other, replace it
+	if !equality.Semantic.DeepEqual(cachedValidatingAdmissionPolicyBinding.Spec, validatingAdmissionPolicyBinding.Spec) {
+		newSpec, err := json.Marshal(validatingAdmissionPolicyBinding.Spec)
+		if err != nil {
+			return patchOps, err
+		}
+
+		patchOps = append(patchOps, fmt.Sprintf(`{ "op": "replace", "path": "/spec", "value": %s }`, string(newSpec)))
+	}
+
+	return patchOps, nil
+}
+
+func (r *Reconciler) createOrUpdateValidatingAdmissionPolicyBindings() error {
+	if !r.stores.ValidatingAdmissionPolicyBindingEnabled {
+		return nil
+	}
+
+	for _, validatingAdmissionPolicyBinding := range r.targetStrategy.ValidatingAdmissionPolicyBindings() {
+		err := r.createOrUpdateValidatingAdmissionPolicyBinding(validatingAdmissionPolicyBinding.DeepCopy())
+		if err != nil {
+			return err
+		}
+	}
+	return nil
+}
+
+func (r *Reconciler) createOrUpdateValidatingAdmissionPolicyBinding(validatingAdmissionPolicyBinding *admissionregistrationv1.ValidatingAdmissionPolicyBinding) error {
+	admissionRegistrationV1 := r.clientset.AdmissionregistrationV1()
+	version, imageRegistry, id := getTargetVersionRegistryID(r.kv)
+
+	injectOperatorMetadata(r.kv, &validatingAdmissionPolicyBinding.ObjectMeta, version, imageRegistry, id, true)
+
+	obj, exists, _ := r.stores.ValidatingAdmissionPolicyBindingCache.Get(validatingAdmissionPolicyBinding)
+
+	if !exists {
+		r.expectations.ValidatingAdmissionPolicyBinding.RaiseExpectations(r.kvKey, 1, 0)
+		_, err := admissionRegistrationV1.ValidatingAdmissionPolicyBindings().Create(context.Background(), validatingAdmissionPolicyBinding, metav1.CreateOptions{})
+		if err != nil {
+			r.expectations.ValidatingAdmissionPolicyBinding.LowerExpectations(r.kvKey, 1, 0)
+			return fmt.Errorf("unable to create validatingAdmissionPolicyBinding %+v: %v", validatingAdmissionPolicyBinding, err)
+		}
+
+		return nil
+	}
+
+	cachedValidatingAdmissionPolicyBinding := obj.(*admissionregistrationv1.ValidatingAdmissionPolicyBinding)
+
+	patchOps, err := generateValidatingAdmissionPolicyBindingPatch(cachedValidatingAdmissionPolicyBinding, validatingAdmissionPolicyBinding)
+	if err != nil {
+		return fmt.Errorf("unable to generate validatingAdmissionPolicyBinding patch operations for %+v: %v", validatingAdmissionPolicyBinding, err)
+	}
+
+	if len(patchOps) == 0 {
+		log.Log.V(4).Infof("validatingAdmissionPolicyBinding %v is up-to-date", validatingAdmissionPolicyBinding.GetName())
+		return nil
+	}
+
+	_, err = admissionRegistrationV1.ValidatingAdmissionPolicyBindings().Patch(context.Background(),
+		validatingAdmissionPolicyBinding.Name,
+		types.JSONPatchType,
+		generatePatchBytes(patchOps),
+		metav1.PatchOptions{})
+	if err != nil {
+		return fmt.Errorf("unable to patch validatingAdmissionPolicyBinding %+v: %v", validatingAdmissionPolicyBinding, err)
+	}
+
+	log.Log.V(2).Infof("validatingAdmissionPolicyBinding %v patched", validatingAdmissionPolicyBinding.GetName())
+	return nil
+}
+
+func generateValidatingAdmissionPolicyPatch(
+	cachedValidatingAdmissionPolicy *admissionregistrationv1.ValidatingAdmissionPolicy,
+	validatingAdmissionPolicy *admissionregistrationv1.ValidatingAdmissionPolicy) ([]string, error) {
+
+	patchOps, err := getObjectMetaPatch(validatingAdmissionPolicy.ObjectMeta, cachedValidatingAdmissionPolicy.ObjectMeta)
+	if err != nil {
+		return nil, err
+	}
+
+	// If the Specs don't equal each other, replace it
+	if !equality.Semantic.DeepEqual(cachedValidatingAdmissionPolicy.Spec, validatingAdmissionPolicy.Spec) {
+		newSpec, err := json.Marshal(validatingAdmissionPolicy.Spec)
+		if err != nil {
+			return patchOps, err
+		}
+
+		patchOps = append(patchOps, fmt.Sprintf(`{ "op": "replace", "path": "/spec", "value": %s }`, string(newSpec)))
+	}
+
+	return patchOps, nil
+}
+
+func (r *Reconciler) createOrUpdateValidatingAdmissionPolicies() error {
+	if !r.stores.ValidatingAdmissionPolicyEnabled {
+		return nil
+	}
+
+	for _, validatingAdmissionPolicy := range r.targetStrategy.ValidatingAdmissionPolicies() {
+		err := r.createOrUpdateValidatingAdmissionPolicy(validatingAdmissionPolicy.DeepCopy())
+		if err != nil {
+			return err
+		}
+	}
+
+	return nil
+}
+
+func (r *Reconciler) createOrUpdateValidatingAdmissionPolicy(validatingAdmissionPolicy *admissionregistrationv1.ValidatingAdmissionPolicy) error {
+	admissionRegistrationV1 := r.clientset.AdmissionregistrationV1()
+	version, imageRegistry, id := getTargetVersionRegistryID(r.kv)
+
+	injectOperatorMetadata(r.kv, &validatingAdmissionPolicy.ObjectMeta, version, imageRegistry, id, true)
+
+	obj, exists, _ := r.stores.ValidatingAdmissionPolicyCache.Get(validatingAdmissionPolicy)
+
+	if !exists {
+		r.expectations.ValidatingAdmissionPolicy.RaiseExpectations(r.kvKey, 1, 0)
+		_, err := admissionRegistrationV1.ValidatingAdmissionPolicies().Create(context.Background(), validatingAdmissionPolicy, metav1.CreateOptions{})
+		if err != nil {
+			r.expectations.ValidatingAdmissionPolicy.LowerExpectations(r.kvKey, 1, 0)
+			return fmt.Errorf("unable to create validatingAdmissionPolicy %+v: %v", validatingAdmissionPolicy, err)
+		}
+
+		return nil
+	}
+
+	cachedValidatingAdmissionPolicy := obj.(*admissionregistrationv1.ValidatingAdmissionPolicy)
+
+	patchOps, err := generateValidatingAdmissionPolicyPatch(cachedValidatingAdmissionPolicy, validatingAdmissionPolicy)
+	if err != nil {
+		return fmt.Errorf("unable to generate validatingAdmissionPolicy patch operations for %+v: %v", validatingAdmissionPolicy, err)
+	}
+
+	if len(patchOps) == 0 {
+		log.Log.V(4).Infof("validatingAdmissionPolicy %v is up-to-date", validatingAdmissionPolicy.GetName())
+		return nil
+	}
+
+	_, err = admissionRegistrationV1.ValidatingAdmissionPolicies().Patch(context.Background(), validatingAdmissionPolicy.Name, types.JSONPatchType, generatePatchBytes(patchOps), metav1.PatchOptions{})
+	if err != nil {
+		return fmt.Errorf("unable to patch validatingAdmissionPolicy %+v: %v", validatingAdmissionPolicy, err)
+	}
+
+	log.Log.V(2).Infof("validatingAdmissionPolicy %v patched", validatingAdmissionPolicy.GetName())
+	return nil
+}
diff --git a/pkg/virt-operator/resource/apply/delete.go b/pkg/virt-operator/resource/apply/delete.go
index ce76166fef26..aaa62f996206 100644
--- a/pkg/virt-operator/resource/apply/delete.go
+++ b/pkg/virt-operator/resource/apply/delete.go
@@ -464,6 +464,42 @@ func DeleteAll(kv *v1.KubeVirt,
 		}
 	}
 
+	objects = stores.ValidatingAdmissionPolicyBindingCache.List()
+	for _, obj := range objects {
+		if validatingAdmissionPolicyBinding, ok := obj.(*admissionregistrationv1.ValidatingAdmissionPolicyBinding); ok && validatingAdmissionPolicyBinding.DeletionTimestamp == nil {
+			if key, err := controller.KeyFunc(validatingAdmissionPolicyBinding); err == nil {
+				expectations.ValidatingAdmissionPolicyBinding.AddExpectedDeletion(kvkey, key)
+				err := clientset.AdmissionregistrationV1().ValidatingAdmissionPolicyBindings().Delete(context.Background(), validatingAdmissionPolicyBinding.Name, deleteOptions)
+				if err != nil {
+					expectations.ValidatingAdmissionPolicyBinding.DeletionObserved(kvkey, key)
+					log.Log.Errorf("Failed to delete validatingAdmissionPolicyBinding %+v: %v", validatingAdmissionPolicyBinding, err)
+					return err
+				}
+			}
+		} else if !ok {
+			log.Log.Errorf(castFailedFmt, obj)
+			return nil
+		}
+	}
+
+	objects = stores.ValidatingAdmissionPolicyCache.List()
+	for _, obj := range objects {
+		if validatingAdmissionPolicy, ok := obj.(*admissionregistrationv1.ValidatingAdmissionPolicy); ok && validatingAdmissionPolicy.DeletionTimestamp == nil {
+			if key, err := controller.KeyFunc(validatingAdmissionPolicy); err == nil {
+				expectations.ValidatingAdmissionPolicy.AddExpectedDeletion(kvkey, key)
+				err := clientset.AdmissionregistrationV1().ValidatingAdmissionPolicies().Delete(context.Background(), validatingAdmissionPolicy.Name, deleteOptions)
+				if err != nil {
+					expectations.ValidatingAdmissionPolicy.DeletionObserved(kvkey, key)
+					log.Log.Errorf("Failed to delete validatingAdmissionPolicy %+v: %v", validatingAdmissionPolicy, err)
+					return err
+				}
+			}
+		} else if !ok {
+			log.Log.Errorf(castFailedFmt, obj)
+			return nil
+		}
+	}
+
 	err = deleteDummyWebhookValidators(kv, clientset, stores, expectations)
 	if err != nil {
 		return err
diff --git a/pkg/virt-operator/resource/apply/reconcile.go b/pkg/virt-operator/resource/apply/reconcile.go
index 236b2ce7f435..37dc8639ed77 100644
--- a/pkg/virt-operator/resource/apply/reconcile.go
+++ b/pkg/virt-operator/resource/apply/reconcile.go
@@ -30,7 +30,6 @@ import (
 	"github.com/blang/semver"
 	promv1 "github.com/coreos/prometheus-operator/pkg/apis/monitoring/v1"
 	secv1 "github.com/openshift/api/security/v1"
-
 	admissionregistrationv1 "k8s.io/api/admissionregistration/v1"
 	appsv1 "k8s.io/api/apps/v1"
 	corev1 "k8s.io/api/core/v1"
@@ -659,6 +658,16 @@ func (r *Reconciler) Sync(queue workqueue.RateLimitingInterface) (bool, error) {
 		return false, nil
 	}
 
+	err = r.createOrUpdateValidatingAdmissionPolicyBindings()
+	if err != nil {
+		return false, err
+	}
+
+	err = r.createOrUpdateValidatingAdmissionPolicies()
+	if err != nil {
+		return false, err
+	}
+
 	err = r.createOrUpdateComponentsWithCertificates(queue)
 	if err != nil {
 		return false, err
@@ -952,6 +961,56 @@ func (r *Reconciler) deleteObjectsNotInInstallStrategy() error {
 		}
 	}
 
+	// remove unused ValidatingAdmissionPolicyBinding
+	objects = r.stores.ValidatingAdmissionPolicyBindingCache.List()
+	for _, obj := range objects {
+		if validatingAdmissionPolicyBinding, ok := obj.(*admissionregistrationv1.ValidatingAdmissionPolicyBinding); ok && validatingAdmissionPolicyBinding.DeletionTimestamp == nil {
+			found := false
+			for _, targetValidatingAdmissionPolicyBinding := range r.targetStrategy.ValidatingAdmissionPolicyBindings() {
+				if targetValidatingAdmissionPolicyBinding.Name == validatingAdmissionPolicyBinding.Name {
+					found = true
+					break
+				}
+			}
+			if !found {
+				if key, err := controller.KeyFunc(validatingAdmissionPolicyBinding); err == nil {
+					r.expectations.ValidatingAdmissionPolicyBinding.AddExpectedDeletion(r.kvKey, key)
+					err := r.clientset.AdmissionregistrationV1().ValidatingAdmissionPolicyBindings().Delete(context.Background(), validatingAdmissionPolicyBinding.Name, deleteOptions)
+					if err != nil {
+						r.expectations.ValidatingAdmissionPolicyBinding.DeletionObserved(r.kvKey, key)
+						log.Log.Errorf("Failed to delete validatingAdmissionPolicyBinding %+v: %v", validatingAdmissionPolicyBinding, err)
+						return err
+					}
+				}
+			}
+		}
+	}
+
+	// remove unused ValidatingAdmissionPolicy
+	objects = r.stores.ValidatingAdmissionPolicyCache.List()
+	for _, obj := range objects {
+		if validatingAdmissionPolicy, ok := obj.(*admissionregistrationv1.ValidatingAdmissionPolicy); ok && validatingAdmissionPolicy.DeletionTimestamp == nil {
+			found := false
+			for _, targetValidatingAdmissionPolicy := range r.targetStrategy.ValidatingAdmissionPolicies() {
+				if targetValidatingAdmissionPolicy.Name == validatingAdmissionPolicy.Name {
+					found = true
+					break
+				}
+			}
+			if !found {
+				if key, err := controller.KeyFunc(validatingAdmissionPolicy); err == nil {
+					r.expectations.ValidatingAdmissionPolicy.AddExpectedDeletion(r.kvKey, key)
+					err := r.clientset.AdmissionregistrationV1().ValidatingAdmissionPolicies().Delete(context.Background(), validatingAdmissionPolicy.Name, deleteOptions)
+					if err != nil {
+						r.expectations.ValidatingAdmissionPolicy.DeletionObserved(r.kvKey, key)
+						log.Log.Errorf("Failed to delete validatingAdmissionPolicy %+v: %v", validatingAdmissionPolicy, err)
+						return err
+					}
+				}
+			}
+		}
+	}
+
 	// remove unused crds
 	objects = r.stores.CrdCache.List()
 	for _, obj := range objects {
diff --git a/pkg/virt-operator/resource/generate/install/strategy.go b/pkg/virt-operator/resource/generate/install/strategy.go
index 0cdfa14ec727..0f0ea0328b8a 100644
--- a/pkg/virt-operator/resource/generate/install/strategy.go
+++ b/pkg/virt-operator/resource/generate/install/strategy.go
@@ -83,18 +83,20 @@ type Strategy struct {
 
 	crds []*extv1.CustomResourceDefinition
 
-	services                        []*corev1.Service
-	deployments                     []*appsv1.Deployment
-	daemonSets                      []*appsv1.DaemonSet
-	validatingWebhookConfigurations []*admissionregistrationv1.ValidatingWebhookConfiguration
-	mutatingWebhookConfigurations   []*admissionregistrationv1.MutatingWebhookConfiguration
-	apiServices                     []*apiregv1.APIService
-	certificateSecrets              []*corev1.Secret
-	sccs                            []*secv1.SecurityContextConstraints
-	serviceMonitors                 []*promv1.ServiceMonitor
-	prometheusRules                 []*promv1.PrometheusRule
-	configMaps                      []*corev1.ConfigMap
-	routes                          []*routev1.Route
+	services                          []*corev1.Service
+	deployments                       []*appsv1.Deployment
+	daemonSets                        []*appsv1.DaemonSet
+	validatingWebhookConfigurations   []*admissionregistrationv1.ValidatingWebhookConfiguration
+	mutatingWebhookConfigurations     []*admissionregistrationv1.MutatingWebhookConfiguration
+	apiServices                       []*apiregv1.APIService
+	certificateSecrets                []*corev1.Secret
+	sccs                              []*secv1.SecurityContextConstraints
+	serviceMonitors                   []*promv1.ServiceMonitor
+	prometheusRules                   []*promv1.PrometheusRule
+	configMaps                        []*corev1.ConfigMap
+	routes                            []*routev1.Route
+	validatingAdmissionPolicyBindings []*admissionregistrationv1.ValidatingAdmissionPolicyBinding
+	validatingAdmissionPolicies       []*admissionregistrationv1.ValidatingAdmissionPolicy
 }
 
 func (ins *Strategy) ServiceAccounts() []*corev1.ServiceAccount {
@@ -220,6 +222,14 @@ func (ins *Strategy) Routes() []*routev1.Route {
 	return ins.routes
 }
 
+func (ins *Strategy) ValidatingAdmissionPolicyBindings() []*admissionregistrationv1.ValidatingAdmissionPolicyBinding {
+	return ins.validatingAdmissionPolicyBindings
+}
+
+func (ins *Strategy) ValidatingAdmissionPolicies() []*admissionregistrationv1.ValidatingAdmissionPolicy {
+	return ins.validatingAdmissionPolicies
+}
+
 func encodeManifests(manifests []byte) (string, error) {
 	var buf bytes.Buffer
 
@@ -373,6 +383,12 @@ func dumpInstallStrategyToBytes(strategy *Strategy) []byte {
 	for _, entry := range strategy.mutatingWebhookConfigurations {
 		marshalutil.MarshallObject(entry, writer)
 	}
+	for _, entry := range strategy.validatingAdmissionPolicyBindings {
+		marshalutil.MarshallObject(entry, writer)
+	}
+	for _, entry := range strategy.validatingAdmissionPolicies {
+		marshalutil.MarshallObject(entry, writer)
+	}
 	for _, entry := range strategy.apiServices {
 		marshalutil.MarshallObject(entry, writer)
 	}
@@ -526,9 +526,18 @@ func GenerateCurrentInstallStrategy(config *operatorutil.KubeVirtDeploymentConfi
 	strategy.configMaps = append(strategy.configMaps, components.NewCAConfigMaps(operatorNamespace)...)
 	strategy.routes = append(strategy.routes, components.GetAllRoutes(operatorNamespace)...)
 
+	strategy.validatingAdmissionPolicyBindings = append(strategy.validatingAdmissionPolicyBindings, components.NewHandlerV1ValidatingAdmissionPolicyBinding())
+	virtHandlerServiceAccount := getVirtHandlerServiceAccount(config.GetNamespace())
+	strategy.validatingAdmissionPolicies = append(strategy.validatingAdmissionPolicies, components.NewHandlerV1ValidatingAdmissionPolicy(virtHandlerServiceAccount))
+
 	return strategy, nil
 }
 
+func getVirtHandlerServiceAccount(namespace string) string {
+	prefix := fmt.Sprintf("system:serviceaccount:%s", namespace)
+	return fmt.Sprintf("%s:%s", prefix, components.HandlerServiceAccountName)
+}
+
 func mostRecentConfigMap(configMaps []*corev1.ConfigMap) *corev1.ConfigMap {
 	var configMap *corev1.ConfigMap
 	// choose the most recent configmap if multiple match.
@@ -674,6 +699,20 @@ func loadInstallStrategyFromBytes(data string) (*Strategy, error) {
 			}
 			webhook.TypeMeta = obj
 			strategy.mutatingWebhookConfigurations = append(strategy.mutatingWebhookConfigurations, webhook)
+		case "ValidatingAdmissionPolicyBinding":
+			validatingAdmissionPolicyBinding := &admissionregistrationv1.ValidatingAdmissionPolicyBinding{}
+			if err := yaml.Unmarshal([]byte(entry), &validatingAdmissionPolicyBinding); err != nil {
+				return nil, err
+			}
+			validatingAdmissionPolicyBinding.TypeMeta = obj
+			strategy.validatingAdmissionPolicyBindings = append(strategy.validatingAdmissionPolicyBindings, validatingAdmissionPolicyBinding)
+		case "ValidatingAdmissionPolicy":
+			validatingAdmissionPolicy := &admissionregistrationv1.ValidatingAdmissionPolicy{}
+			if err := yaml.Unmarshal([]byte(entry), &validatingAdmissionPolicy); err != nil {
+				return nil, err
+			}
+			validatingAdmissionPolicy.TypeMeta = obj
+			strategy.validatingAdmissionPolicies = append(strategy.validatingAdmissionPolicies, validatingAdmissionPolicy)
 		case "APIService":
 			apiService := &apiregv1.APIService{}
 			if err := yaml.Unmarshal([]byte(entry), &apiService); err != nil {
diff --git a/pkg/virt-operator/util/BUILD.bazel b/pkg/virt-operator/util/BUILD.bazel
index 0f06af4a218f..c713f6627a85 100644
--- a/pkg/virt-operator/util/BUILD.bazel
+++ b/pkg/virt-operator/util/BUILD.bazel
@@ -21,6 +21,7 @@ go_library(
         "//staging/src/kubevirt.io/client-go/version:go_default_library",
         "//vendor/github.com/coreos/prometheus-operator/pkg/apis/monitoring/v1:go_default_library",
         "//vendor/github.com/openshift/api/security/v1:go_default_library",
+        "//vendor/k8s.io/api/admissionregistration/v1:go_default_library",
         "//vendor/k8s.io/api/apps/v1:go_default_library",
         "//vendor/k8s.io/api/core/v1:go_default_library",
         "//vendor/k8s.io/apimachinery/pkg/apis/meta/v1:go_default_library",
diff --git a/pkg/virt-operator/util/client.go b/pkg/virt-operator/util/client.go
index c797cc8f62ad..6aedc92a86c1 100644
--- a/pkg/virt-operator/util/client.go
+++ b/pkg/virt-operator/util/client.go
@@ -24,6 +24,7 @@ import (
 	"time"
 
 	promv1 "github.com/coreos/prometheus-operator/pkg/apis/monitoring/v1"
+	admissionregistrationv1 "k8s.io/api/admissionregistration/v1"
 	"k8s.io/client-go/discovery"
 
 	k8sv1 "k8s.io/api/core/v1"
@@ -230,3 +231,45 @@ func IsPrometheusRuleEnabled(clientset kubecli.KubevirtClient) (bool, error) {
 
 	return false, nil
 }
+
+// IsValidatingAdmissionPolicyBindingEnabled returns true if ValidatingAdmissionPolicyBinding resource is defined
+// and false otherwise.
+func IsValidatingAdmissionPolicyBindingEnabled(clientset kubecli.KubevirtClient) (bool, error) {
+	_, apis, err := clientset.DiscoveryClient().ServerGroupsAndResources()
+	if err != nil && !discovery.IsGroupDiscoveryFailedError(err) {
+		return false, err
+	}
+
+	for _, api := range apis {
+		if api.GroupVersion == admissionregistrationv1.SchemeGroupVersion.String() {
+			for _, resource := range api.APIResources {
+				if resource.Name == "validatingadmissionpolicybindings" {
+					return true, nil
+				}
+			}
+		}
+	}
+
+	return false, nil
+}
+
+// IsValidatingAdmissionPolicyEnabled returns true if ValidatingAdmissionPolicy resource is defined
+// and false otherwise.
+func IsValidatingAdmissionPolicyEnabled(clientset kubecli.KubevirtClient) (bool, error) {
+	_, apis, err := clientset.DiscoveryClient().ServerGroupsAndResources()
+	if err != nil && !discovery.IsGroupDiscoveryFailedError(err) {
+		return false, err
+	}
+
+	for _, api := range apis {
+		if api.GroupVersion == admissionregistrationv1.SchemeGroupVersion.String() {
+			for _, resource := range api.APIResources {
+				if resource.Name == "validatingadmissionpolicies" {
+					return true, nil
+				}
+			}
+		}
+	}
+
+	return false, nil
+}
diff --git a/pkg/virt-operator/util/types.go b/pkg/virt-operator/util/types.go
index 96a2a98da7a7..227ee1fae355 100644
--- a/pkg/virt-operator/util/types.go
+++ b/pkg/virt-operator/util/types.go
@@ -28,32 +28,36 @@ import (
 )
 
 type Stores struct {
-	ServiceAccountCache           cache.Store
-	ClusterRoleCache              cache.Store
-	ClusterRoleBindingCache       cache.Store
-	RoleCache                     cache.Store
-	RoleBindingCache              cache.Store
-	CrdCache                      cache.Store
-	ServiceCache                  cache.Store
-	DeploymentCache               cache.Store
-	DaemonSetCache                cache.Store
-	ValidationWebhookCache        cache.Store
-	MutatingWebhookCache          cache.Store
-	APIServiceCache               cache.Store
-	SCCCache                      cache.Store
-	RouteCache                    cache.Store
-	InstallStrategyConfigMapCache cache.Store
-	InstallStrategyJobCache       cache.Store
-	InfrastructurePodCache        cache.Store
-	PodDisruptionBudgetCache      cache.Store
-	ServiceMonitorCache           cache.Store
-	NamespaceCache                cache.Store
-	PrometheusRuleCache           cache.Store
-	SecretCache                   cache.Store
-	ConfigMapCache                cache.Store
-	IsOnOpenshift                 bool
-	ServiceMonitorEnabled         bool
-	PrometheusRulesEnabled        bool
+	ServiceAccountCache                     cache.Store
+	ClusterRoleCache                        cache.Store
+	ClusterRoleBindingCache                 cache.Store
+	RoleCache                               cache.Store
+	RoleBindingCache                        cache.Store
+	CrdCache                                cache.Store
+	ServiceCache                            cache.Store
+	DeploymentCache                         cache.Store
+	DaemonSetCache                          cache.Store
+	ValidationWebhookCache                  cache.Store
+	MutatingWebhookCache                    cache.Store
+	APIServiceCache                         cache.Store
+	SCCCache                                cache.Store
+	RouteCache                              cache.Store
+	InstallStrategyConfigMapCache           cache.Store
+	InstallStrategyJobCache                 cache.Store
+	InfrastructurePodCache                  cache.Store
+	PodDisruptionBudgetCache                cache.Store
+	ServiceMonitorCache                     cache.Store
+	NamespaceCache                          cache.Store
+	PrometheusRuleCache                     cache.Store
+	SecretCache                             cache.Store
+	ConfigMapCache                          cache.Store
+	ValidatingAdmissionPolicyBindingCache   cache.Store
+	ValidatingAdmissionPolicyCache          cache.Store
+	IsOnOpenshift                           bool
+	ServiceMonitorEnabled                   bool
+	PrometheusRulesEnabled                  bool
+	ValidatingAdmissionPolicyBindingEnabled bool
+	ValidatingAdmissionPolicyEnabled        bool
 }
 
 func (s *Stores) AllEmpty() bool {
@@ -75,7 +79,9 @@ func (s *Stores) AllEmpty() bool {
 		IsStoreEmpty(s.ServiceMonitorCache) &&
 		IsStoreEmpty(s.PrometheusRuleCache) &&
 		IsStoreEmpty(s.SecretCache) &&
-		IsStoreEmpty(s.ConfigMapCache)
+		IsStoreEmpty(s.ConfigMapCache) &&
+		IsStoreEmpty(s.ValidatingAdmissionPolicyBindingCache) &&
+		IsStoreEmpty(s.ValidatingAdmissionPolicyCache)
 
 	// Don't add InstallStrategyConfigMapCache to this list. The install
 	// strategies persist even after deletion and updates.
@@ -103,53 +109,57 @@ func IsSCCStoreEmpty(store cache.Store) bool {
 }
 
 type Expectations struct {
-	ServiceAccount           *controller.UIDTrackingControllerExpectations
-	ClusterRole              *controller.UIDTrackingControllerExpectations
-	ClusterRoleBinding       *controller.UIDTrackingControllerExpectations
-	Role                     *controller.UIDTrackingControllerExpectations
-	RoleBinding              *controller.UIDTrackingControllerExpectations
-	Crd                      *controller.UIDTrackingControllerExpectations
-	Service                  *controller.UIDTrackingControllerExpectations
-	Deployment               *controller.UIDTrackingControllerExpectations
-	DaemonSet                *controller.UIDTrackingControllerExpectations
-	ValidationWebhook        *controller.UIDTrackingControllerExpectations
-	MutatingWebhook          *controller.UIDTrackingControllerExpectations
-	APIService               *controller.UIDTrackingControllerExpectations
-	SCC                      *controller.UIDTrackingControllerExpectations
-	Route                    *controller.UIDTrackingControllerExpectations
-	InstallStrategyConfigMap *controller.UIDTrackingControllerExpectations
-	InstallStrategyJob       *controller.UIDTrackingControllerExpectations
-	PodDisruptionBudget      *controller.UIDTrackingControllerExpectations
-	ServiceMonitor           *controller.UIDTrackingControllerExpectations
-	PrometheusRule           *controller.UIDTrackingControllerExpectations
-	Secrets                  *controller.UIDTrackingControllerExpectations
-	ConfigMap                *controller.UIDTrackingControllerExpectations
+	ServiceAccount                   *controller.UIDTrackingControllerExpectations
+	ClusterRole                      *controller.UIDTrackingControllerExpectations
+	ClusterRoleBinding               *controller.UIDTrackingControllerExpectations
+	Role                             *controller.UIDTrackingControllerExpectations
+	RoleBinding                      *controller.UIDTrackingControllerExpectations
+	Crd                              *controller.UIDTrackingControllerExpectations
+	Service                          *controller.UIDTrackingControllerExpectations
+	Deployment                       *controller.UIDTrackingControllerExpectations
+	DaemonSet                        *controller.UIDTrackingControllerExpectations
+	ValidationWebhook                *controller.UIDTrackingControllerExpectations
+	MutatingWebhook                  *controller.UIDTrackingControllerExpectations
+	APIService                       *controller.UIDTrackingControllerExpectations
+	SCC                              *controller.UIDTrackingControllerExpectations
+	Route                            *controller.UIDTrackingControllerExpectations
+	InstallStrategyConfigMap         *controller.UIDTrackingControllerExpectations
+	InstallStrategyJob               *controller.UIDTrackingControllerExpectations
+	PodDisruptionBudget              *controller.UIDTrackingControllerExpectations
+	ServiceMonitor                   *controller.UIDTrackingControllerExpectations
+	PrometheusRule                   *controller.UIDTrackingControllerExpectations
+	Secrets                          *controller.UIDTrackingControllerExpectations
+	ConfigMap                        *controller.UIDTrackingControllerExpectations
+	ValidatingAdmissionPolicyBinding *controller.UIDTrackingControllerExpectations
+	ValidatingAdmissionPolicy        *controller.UIDTrackingControllerExpectations
 }
 
 type Informers struct {
-	ServiceAccount           cache.SharedIndexInformer
-	ClusterRole              cache.SharedIndexInformer
-	ClusterRoleBinding       cache.SharedIndexInformer
-	Role                     cache.SharedIndexInformer
-	RoleBinding              cache.SharedIndexInformer
-	Crd                      cache.SharedIndexInformer
-	Service                  cache.SharedIndexInformer
-	Deployment               cache.SharedIndexInformer
-	DaemonSet                cache.SharedIndexInformer
-	ValidationWebhook        cache.SharedIndexInformer
-	MutatingWebhook          cache.SharedIndexInformer
-	APIService               cache.SharedIndexInformer
-	SCC                      cache.SharedIndexInformer
-	Route                    cache.SharedIndexInformer
-	InstallStrategyConfigMap cache.SharedIndexInformer
-	InstallStrategyJob       cache.SharedIndexInformer
-	InfrastructurePod        cache.SharedIndexInformer
-	PodDisruptionBudget      cache.SharedIndexInformer
-	ServiceMonitor           cache.SharedIndexInformer
-	Namespace                cache.SharedIndexInformer
-	PrometheusRule           cache.SharedIndexInformer
-	Secrets                  cache.SharedIndexInformer
-	ConfigMap                cache.SharedIndexInformer
+	ServiceAccount                   cache.SharedIndexInformer
+	ClusterRole                      cache.SharedIndexInformer
+	ClusterRoleBinding               cache.SharedIndexInformer
+	Role                             cache.SharedIndexInformer
+	RoleBinding                      cache.SharedIndexInformer
+	Crd                              cache.SharedIndexInformer
+	Service                          cache.SharedIndexInformer
+	Deployment                       cache.SharedIndexInformer
+	DaemonSet                        cache.SharedIndexInformer
+	ValidationWebhook                cache.SharedIndexInformer
+	MutatingWebhook                  cache.SharedIndexInformer
+	APIService                       cache.SharedIndexInformer
+	SCC                              cache.SharedIndexInformer
+	Route                            cache.SharedIndexInformer
+	InstallStrategyConfigMap         cache.SharedIndexInformer
+	InstallStrategyJob               cache.SharedIndexInformer
+	InfrastructurePod                cache.SharedIndexInformer
+	PodDisruptionBudget              cache.SharedIndexInformer
+	ServiceMonitor                   cache.SharedIndexInformer
+	Namespace                        cache.SharedIndexInformer
+	PrometheusRule                   cache.SharedIndexInformer
+	Secrets                          cache.SharedIndexInformer
+	ConfigMap                        cache.SharedIndexInformer
+	ValidatingAdmissionPolicyBinding cache.SharedIndexInformer
+	ValidatingAdmissionPolicy        cache.SharedIndexInformer
 }
 
 func (e *Expectations) DeleteExpectations(key string) {
@@ -174,6 +184,8 @@ func (e *Expectations) DeleteExpectations(key string) {
 	e.PrometheusRule.DeleteExpectations(key)
 	e.Secrets.DeleteExpectations(key)
 	e.ConfigMap.DeleteExpectations(key)
+	e.ValidatingAdmissionPolicyBinding.DeleteExpectations(key)
+	e.ValidatingAdmissionPolicy.DeleteExpectations(key)
 }
 
 func (e *Expectations) ResetExpectations(key string) {
@@ -198,6 +210,8 @@ func (e *Expectations) ResetExpectations(key string) {
 	e.PrometheusRule.SetExpectations(key, 0, 0)
 	e.Secrets.SetExpectations(key, 0, 0)
 	e.ConfigMap.SetExpectations(key, 0, 0)
+	e.ValidatingAdmissionPolicyBinding.SetExpectations(key, 0, 0)
+	e.ValidatingAdmissionPolicy.SetExpectations(key, 0, 0)
 }
 
 func (e *Expectations) SatisfiedExpectations(key string) bool {
@@ -221,5 +235,7 @@ func (e *Expectations) SatisfiedExpectations(key string) bool {
 		e.ServiceMonitor.SatisfiedExpectations(key) &&
 		e.PrometheusRule.SatisfiedExpectations(key) &&
 		e.Secrets.SatisfiedExpectations(key) &&
-		e.ConfigMap.SatisfiedExpectations(key)
+		e.ConfigMap.SatisfiedExpectations(key) &&
+		e.ValidatingAdmissionPolicyBinding.SatisfiedExpectations(key) &&
+		e.ValidatingAdmissionPolicy.SatisfiedExpectations(key)
 }

From 48406b097f4e3f0ce0688d33acaff1808991b280 Mon Sep 17 00:00:00 2001
From: Ram Lavi <ralavi@redhat.com>
Date: Tue, 4 Jun 2024 11:54:41 +0300
Subject: [PATCH 4/4] virt-operator: Adding node restrictions e2e tests

The tests will only run if validatingadmissionpolicies resource is
available on the cluster.

Signed-off-by: Ram Lavi <ralavi@redhat.com>
Signed-off-by: fossedihelm <ffossemo@redhat.com>
---
 tests/BUILD.bazel                             |   1 +
 tests/tests_suite_test.go                     |   1 +
 tests/validatingadmissionpolicy/BUILD.bazel   |  24 +++
 .../noderestrictions.go                       | 196 ++++++++++++++++++
 4 files changed, 222 insertions(+)
 create mode 100644 tests/validatingadmissionpolicy/BUILD.bazel
 create mode 100644 tests/validatingadmissionpolicy/noderestrictions.go

diff --git a/tests/BUILD.bazel b/tests/BUILD.bazel
index d19113a1f190..81730779dd2f 100644
--- a/tests/BUILD.bazel
+++ b/tests/BUILD.bazel
@@ -230,6 +230,7 @@ go_test(
         "//tests/testsuite:go_default_library",
         "//tests/util:go_default_library",
+        "//tests/validatingadmissionpolicy:go_default_library",
         "//tests/virtctl:go_default_library",
         "//tests/watcher:go_default_library",
         "//tools/vms-generator/utils:go_default_library",
         "//vendor/github.com/google/goexpect:go_default_library",
diff --git a/tests/tests_suite_test.go b/tests/tests_suite_test.go
index 91a94338652a..fb43329496f1 100644
--- a/tests/tests_suite_test.go
+++ b/tests/tests_suite_test.go
@@ -50,6 +50,7 @@ import (
 	_ "kubevirt.io/kubevirt/tests/realtime"
 	_ "kubevirt.io/kubevirt/tests/scale"
 	_ "kubevirt.io/kubevirt/tests/storage"
+	_ "kubevirt.io/kubevirt/tests/validatingadmissionpolicy"
 	_ "kubevirt.io/kubevirt/tests/virtctl"
 )
 
diff --git a/tests/validatingadmissionpolicy/BUILD.bazel b/tests/validatingadmissionpolicy/BUILD.bazel
new file mode 100644
index 000000000000..7cdf0c324a48
--- /dev/null
+++ b/tests/validatingadmissionpolicy/BUILD.bazel
@@ -0,0 +1,24 @@
+load("@io_bazel_rules_go//go:def.bzl", "go_library")
+
+go_library(
+    name = "go_default_library",
+    srcs = ["noderestrictions.go"],
+    importpath = "kubevirt.io/kubevirt/tests/validatingadmissionpolicy",
+    visibility = ["//visibility:public"],
+    deps = [
+        "//pkg/apimachinery/patch:go_default_library",
+        "//pkg/virt-operator/resource/generate/components:go_default_library",
+        "//pkg/virt-operator/util:go_default_library",
+        "//staging/src/kubevirt.io/client-go/kubecli:go_default_library",
+        "//tests/decorators:go_default_library",
+        "//tests/exec:go_default_library",
+        "//tests/framework/kubevirt:go_default_library",
+        "//tests/libnode:go_default_library",
+        "//vendor/github.com/onsi/ginkgo/v2:go_default_library",
+        "//vendor/github.com/onsi/gomega:go_default_library",
+        "//vendor/k8s.io/apimachinery/pkg/apis/meta/v1:go_default_library",
+        "//vendor/k8s.io/apimachinery/pkg/types:go_default_library",
+        "//vendor/k8s.io/apimachinery/pkg/util/strategicpatch:go_default_library",
+        "//vendor/k8s.io/client-go/rest:go_default_library",
+    ],
+)
diff --git a/tests/validatingadmissionpolicy/noderestrictions.go b/tests/validatingadmissionpolicy/noderestrictions.go
new file mode 100644
index 000000000000..a8dc8da17fa3
--- /dev/null
+++ b/tests/validatingadmissionpolicy/noderestrictions.go
@@ -0,0 +1,196 @@
+/*
+ * This file is part of the KubeVirt project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * Copyright The KubeVirt Authors.
+ *
+ */
+
+package validatingadmissionpolicy
+
+import (
+	"context"
+	"encoding/json"
+	"fmt"
+
+	. "github.com/onsi/ginkgo/v2"
+	. "github.com/onsi/gomega"
+
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/apimachinery/pkg/types"
+	"k8s.io/apimachinery/pkg/util/strategicpatch"
+
+	"k8s.io/client-go/rest"
+
+	"kubevirt.io/client-go/kubecli"
+
+	"kubevirt.io/kubevirt/pkg/apimachinery/patch"
+	"kubevirt.io/kubevirt/pkg/virt-operator/resource/generate/components"
+	"kubevirt.io/kubevirt/pkg/virt-operator/util"
+	"kubevirt.io/kubevirt/tests/decorators"
+	"kubevirt.io/kubevirt/tests/exec"
+	"kubevirt.io/kubevirt/tests/framework/kubevirt"
+	"kubevirt.io/kubevirt/tests/libnode"
+)
+
+var _ = Describe("[Serial][sig-compute] virt-handler node restrictions via validatingAdmissionPolicy", decorators.SigCompute, decorators.Kubernetes130, Serial, func() {
+	const (
+		notAllowedLabelPath      = "/metadata/labels/other.io~1notAllowedLabel"
+		notAllowedAnnotationPath = "/metadata/annotations/other.io~1notAllowedAnnotation"
+		allowedLabelPath         = "/metadata/labels/kubevirt.io~1allowedLabel"
+		allowedAnnotationPath    = "/metadata/annotations/kubevirt.io~1allowedAnnotation"
+	)
+	var virtClient kubecli.KubevirtClient
+	var nodeName string
+
+	BeforeEach(func() {
+		virtClient = kubevirt.Client()
+		isValidatingAdmissionPolicyEnabled, err := util.IsValidatingAdmissionPolicyEnabled(virtClient)
+		Expect(err).ToNot(HaveOccurred())
+		Expect(isValidatingAdmissionPolicyEnabled).To(BeTrue(), "ValidatingAdmissionPolicy should be enabled")
+		_, err = virtClient.AdmissionregistrationV1().ValidatingAdmissionPolicies().Get(context.Background(), "kubevirt-node-restriction-policy", metav1.GetOptions{})
+		Expect(err).ToNot(HaveOccurred(), "validating admission policy should appear")
+		_, err = virtClient.AdmissionregistrationV1().ValidatingAdmissionPolicyBindings().Get(context.Background(), "kubevirt-node-restriction-binding", metav1.GetOptions{})
+		Expect(err).ToNot(HaveOccurred(), "validating admission policy binding should appear")
+
+		nodesList, err := virtClient.CoreV1().Nodes().List(context.TODO(), metav1.ListOptions{})
+		Expect(err).ToNot(HaveOccurred())
+
+		Expect(nodesList.Items).ToNot(BeEmpty())
+		nodeName = nodesList.Items[0].Name
+		patchBytes, err := patch.New(
+			patch.WithAdd(notAllowedLabelPath, "value"),
+			patch.WithAdd(notAllowedAnnotationPath, "value"),
+			patch.WithAdd(allowedLabelPath, "value"),
+			patch.WithAdd(allowedAnnotationPath, "value"),
+		).GeneratePayload()
+		Expect(err).ToNot(HaveOccurred())
+
+		_, err = virtClient.CoreV1().Nodes().Patch(context.Background(), nodeName, types.JSONPatchType, patchBytes, metav1.PatchOptions{})
+		Expect(err).ToNot(HaveOccurred())
+	})
+
+	AfterEach(func() {
+		node, err := virtClient.CoreV1().Nodes().Get(context.Background(), nodeName, metav1.GetOptions{})
+		Expect(err).ToNot(HaveOccurred())
+
+		old, err := json.Marshal(node)
+		Expect(err).ToNot(HaveOccurred())
+		newNode := node.DeepCopy()
+		delete(newNode.Labels, "other.io/notAllowedLabel")
+		delete(newNode.Annotations, "other.io/notAllowedAnnotation")
+		delete(newNode.Labels, "kubevirt.io/allowedLabel")
+		delete(newNode.Annotations, "kubevirt.io/allowedAnnotation")
+
+		newJSON, err := json.Marshal(newNode)
+		Expect(err).ToNot(HaveOccurred())
+
+		patchBytes, err := strategicpatch.CreateTwoWayMergePatch(old, newJSON, node)
+		Expect(err).ToNot(HaveOccurred())
+
+		_, err = virtClient.CoreV1().Nodes().Patch(
+			context.Background(), node.Name, types.StrategicMergePatchType, patchBytes, metav1.PatchOptions{})
+		Expect(err).ToNot(HaveOccurred())
+	})
+
+	type testPatchMap struct {
+		patchSet      *patch.PatchSet
+		expectedError string
+	}
+
+	It("reject not allowed patches to node", func() {
+		patchSetList := map[string]testPatchMap{
+			"patch spec":          {patch.New(patch.WithAdd("/spec/unschedulable", true)), components.NodeRestrictionErrModifySpec},
+			"metadata patch":      {patch.New(patch.WithAdd("/metadata/finalizers", []string{"kubernetes.io/evil-finalizer"})), components.NodeRestrictionErrChangeMetadataFields},
+			"label addition":      {patch.New(patch.WithAdd("/metadata/labels/other.io~1newNotAllowedLabel", "value")), components.NodeRestrictionErrAddDeleteLabels},
+			"label update":        {patch.New(patch.WithReplace(notAllowedLabelPath, "other-value")), components.NodeRestrictionErrUpdateLabels},
+			"label removal":       {patch.New(patch.WithRemove(notAllowedLabelPath)), components.NodeRestrictionErrAddDeleteLabels},
+			"annotation addition": {patch.New(patch.WithAdd("/metadata/annotations/other.io~1newNotAllowedAnnotation", "value")), components.NodeRestrictionErrAddDeleteAnnotations},
+			"annotation update":   {patch.New(patch.WithReplace(notAllowedAnnotationPath, "other-value")), components.NodeRestrictionErrUpdateAnnotations},
+			"annotation removal":  {patch.New(patch.WithRemove(notAllowedAnnotationPath)), components.NodeRestrictionErrAddDeleteAnnotations},
+		}
+		node, err := virtClient.CoreV1().Nodes().Get(context.Background(), nodeName, metav1.GetOptions{})
+		Expect(err).ToNot(HaveOccurred())
+
+		pod, err := libnode.GetVirtHandlerPod(virtClient, nodeName)
+		Expect(err).ToNot(HaveOccurred())
+
+		token, err := exec.ExecuteCommandOnPod(
+			pod,
+			"virt-handler",
+			[]string{"cat",
+				"/var/run/secrets/kubernetes.io/serviceaccount/token",
+			},
+		)
+		Expect(err).ToNot(HaveOccurred())
+
+		handlerClient, err := kubecli.GetKubevirtClientFromRESTConfig(&rest.Config{
+			Host: virtClient.Config().Host,
+			TLSClientConfig: rest.TLSClientConfig{
+				Insecure: true,
+			},
+			BearerToken: token,
+		})
+		Expect(err).ToNot(HaveOccurred())
+
+		for description, patchItem := range patchSetList {
+			nodePatch, err := patchItem.patchSet.GeneratePayload()
+			Expect(err).ToNot(HaveOccurred())
+			_, err = handlerClient.CoreV1().Nodes().Patch(context.TODO(), node.Name, types.JSONPatchType, nodePatch, metav1.PatchOptions{})
+			Expect(err).To(HaveOccurred(), fmt.Sprintf("%s should fail on node specific node restriction", description))
+			Expect(err.Error()).To(ContainSubstring(patchItem.expectedError), fmt.Sprintf("%s should match specific error", description))
+		}
+	})
+
+	It("allow kubevirt related patches to node", func() {
+		patchSetList := map[string]*patch.PatchSet{
+			"kubevirt.io label addition":      patch.New(patch.WithAdd("/metadata/labels/kubevirt.io~1newAllowedLabel", "value")),
+			"kubevirt.io label update":        patch.New(patch.WithReplace(allowedLabelPath, "other-value")),
+			"kubevirt.io label removal":       patch.New(patch.WithRemove(allowedLabelPath)),
+			"kubevirt.io annotation addition": patch.New(patch.WithAdd("/metadata/annotations/kubevirt.io~1newAllowedAnnotation", "value")),
+			"kubevirt.io annotation update":   patch.New(patch.WithReplace(allowedAnnotationPath, "other-value")),
+			"kubevirt.io annotation removal":  patch.New(patch.WithRemove(allowedAnnotationPath)),
+		}
+		node, err := virtClient.CoreV1().Nodes().Get(context.Background(), nodeName, metav1.GetOptions{})
+		Expect(err).ToNot(HaveOccurred())
+
+		pod, err := libnode.GetVirtHandlerPod(virtClient, node.Name)
+		Expect(err).ToNot(HaveOccurred())
+
+		token, err := exec.ExecuteCommandOnPod(
+			pod,
+			"virt-handler",
+			[]string{"cat",
+				"/var/run/secrets/kubernetes.io/serviceaccount/token",
+			},
+		)
+
+		Expect(err).ToNot(HaveOccurred())
+		handlerClient, err := kubecli.GetKubevirtClientFromRESTConfig(&rest.Config{
+			Host: virtClient.Config().Host,
+			TLSClientConfig: rest.TLSClientConfig{
+				Insecure: true,
+			},
+			BearerToken: token,
+		})
+		Expect(err).ToNot(HaveOccurred())
+
+		for description, patchSet := range patchSetList {
+			nodePatch, err := patchSet.GeneratePayload()
+			Expect(err).ToNot(HaveOccurred())
+			_, err = handlerClient.CoreV1().Nodes().Patch(context.TODO(), node.Name, types.JSONPatchType, nodePatch, metav1.PatchOptions{})
+			Expect(err).ToNot(HaveOccurred(), fmt.Sprintf("%s should not fail on node specific node restriction", description))
+		}
+	})
+})
From 5fc09595bb88f4e0ae2998dcc1a271cf810d77fc Mon Sep 17 00:00:00 2001
From: Luboslav Pivarc <lpivarc@redhat.com>
Date: Thu, 30 May 2024 10:37:24 +0200
Subject: [PATCH 1/3] Node restiction

Introduce NodeRestriction feature gate. This enables
us to check if a virt-handler request is authorized to
modify VMI.

This feature requires following Kubernetes feature gate
ServiceAccountTokenPodNodeInfo. The feature gate is available
in 1.30 as Beta.

Signed-off-by: Luboslav Pivarc <lpivarc@redhat.com>
---
 pkg/virt-api/webhooks/utils.go                |  18 +-
 .../validating-webhook/admitters/BUILD.bazel  |   2 +
 .../admitters/vmi-update-admitter.go          |  43 ++++-
 .../admitters/vmi-update-admitter_test.go     | 156 ++++++++++++++++++
 pkg/virt-config/feature-gates.go              |  11 ++
 tests/decorators/decorators.go                |   3 +
 8 files changed, 336 insertions(+), 6 deletions(-)
 create mode 100644 tests/infrastructure/security.go

diff --git a/pkg/virt-api/webhooks/utils.go b/pkg/virt-api/webhooks/utils.go
index 1307cb366fdb..e6ee54431f91 100644
--- a/pkg/virt-api/webhooks/utils.go
+++ b/pkg/virt-api/webhooks/utils.go
@@ -79,7 +79,11 @@ type Informers struct {
 	DataSourceInformer cache.SharedIndexInformer
 }
 
-func IsKubeVirtServiceAccount(serviceAccount string) bool {
+func IsComponentServiceAccount(serviceAccount, namespace, component string) bool {
+	return serviceAccount == fmt.Sprintf("system:serviceaccount:%s:%s", namespace, component)
+}
+
+func GetNamespace() string {
 	ns, err := clientutil.GetNamespace()
 	logger := log.DefaultLogger()
 
@@ -87,11 +91,14 @@ func IsKubeVirtServiceAccount(serviceAccount string) bool {
 		logger.Info("Failed to get namespace. Fallback to default: 'kubevirt'")
 		ns = "kubevirt"
 	}
+	return ns
+}
 
-	prefix := fmt.Sprintf("system:serviceaccount:%s", ns)
-	return serviceAccount == fmt.Sprintf("%s:%s", prefix, rbac.ApiServiceAccountName) ||
-		serviceAccount == fmt.Sprintf("%s:%s", prefix, rbac.HandlerServiceAccountName) ||
-		serviceAccount == fmt.Sprintf("%s:%s", prefix, rbac.ControllerServiceAccountName)
+func IsKubeVirtServiceAccount(serviceAccount string) bool {
+	ns := GetNamespace()
+	return IsComponentServiceAccount(serviceAccount, ns, components.ApiServiceAccountName) ||
+		IsComponentServiceAccount(serviceAccount, ns, components.HandlerServiceAccountName) ||
+		IsComponentServiceAccount(serviceAccount, ns, components.ControllerServiceAccountName)
 }
 
 func IsARM64() bool {
diff --git a/pkg/virt-api/webhooks/validating-webhook/admitters/BUILD.bazel b/pkg/virt-api/webhooks/validating-webhook/admitters/BUILD.bazel
index 1a71fdf6eab2..8c507b7d9bc2 100644
--- a/pkg/virt-api/webhooks/validating-webhook/admitters/BUILD.bazel
+++ b/pkg/virt-api/webhooks/validating-webhook/admitters/BUILD.bazel
@@ -43,6 +43,7 @@ go_library(
         "//pkg/virt-config:go_default_library",
         "//pkg/virt-handler/node-labeller/util:go_default_library",
         "//pkg/virt-operator/resource/generate/rbac:go_default_library",
+        "//pkg/virt-operator/resource/generate/components:go_default_library",
         "//staging/src/kubevirt.io/api/clone:go_default_library",
         "//staging/src/kubevirt.io/api/clone/v1alpha1:go_default_library",
         "//staging/src/kubevirt.io/api/core:go_default_library",
@@ -135,6 +136,7 @@ go_test(
         "//vendor/github.com/golang/mock/gomock:go_default_library",
         "//vendor/github.com/onsi/ginkgo/v2:go_default_library",
         "//vendor/github.com/onsi/gomega:go_default_library",
+        "//vendor/github.com/onsi/gomega/gstruct:go_default_library",
         "//vendor/github.com/onsi/gomega/types:go_default_library",
         "//vendor/k8s.io/api/admission/v1:go_default_library",
         "//vendor/k8s.io/api/authentication/v1:go_default_library",
diff --git a/pkg/virt-api/webhooks/validating-webhook/admitters/vmi-update-admitter.go b/pkg/virt-api/webhooks/validating-webhook/admitters/vmi-update-admitter.go
index b33f167eb37b..2c56c4be80dd 100644
--- a/pkg/virt-api/webhooks/validating-webhook/admitters/vmi-update-admitter.go
+++ b/pkg/virt-api/webhooks/validating-webhook/admitters/vmi-update-admitter.go
@@ -29,18 +29,20 @@ import (
 
 	"kubevirt.io/kubevirt/pkg/virt-api/webhooks"
 	virtconfig "kubevirt.io/kubevirt/pkg/virt-config"
+	"kubevirt.io/kubevirt/pkg/virt-operator/resource/generate/components"
 
 	v1 "kubevirt.io/api/core/v1"
 
 	webhookutils "kubevirt.io/kubevirt/pkg/util/webhooks"
 )
 
+const nodeNameExtraInfo = "authentication.kubernetes.io/node-name"
+
 type VMIUpdateAdmitter struct {
 	ClusterConfig *virtconfig.ClusterConfig
 }
 
 func (admitter *VMIUpdateAdmitter) Admit(ar *admissionv1.AdmissionReview) *admissionv1.AdmissionResponse {
-
 	if resp := webhookutils.ValidateSchema(v1.VirtualMachineInstanceGroupVersionKind, ar.Request.Object.Raw); resp != nil {
 		return resp
 	}
@@ -50,6 +52,45 @@ func (admitter *VMIUpdateAdmitter) Admit(ar *admissionv1.AdmissionReview) *admis
 		return webhookutils.ToAdmissionResponseError(err)
 	}
 
+	if admitter.ClusterConfig.NodeRestrictionEnabled() && webhooks.IsComponentServiceAccount(ar.Request.UserInfo.Username, webhooks.GetNamespace(), components.HandlerServiceAccountName) {
+		values, exist := ar.Request.UserInfo.Extra[nodeNameExtraInfo]
+		if exist && len(values) > 0 {
+			nodeName := values[0]
+			sourceNode := oldVMI.Status.NodeName
+			targetNode := ""
+			if oldVMI.Status.MigrationState != nil {
+				targetNode = oldVMI.Status.MigrationState.TargetNode
+			}
+
+			// Check that source or target is making this request
+			if nodeName != sourceNode && (targetNode == "" || nodeName != targetNode) {
+				return webhookutils.ToAdmissionResponse([]metav1.StatusCause{
+					{
+						Type:    metav1.CauseTypeFieldValueInvalid,
+						Message: "Node restriction, virt-handler is only allowed to modify VMIs it owns",
+					},
+				})
+			}
+
+			// Check that handler is not setting target
+			if targetNode == "" && newVMI.Status.MigrationState != nil && newVMI.Status.MigrationState.TargetNode != targetNode {
+				return webhookutils.ToAdmissionResponse([]metav1.StatusCause{
+					{
+						Type:    metav1.CauseTypeFieldValueInvalid,
+						Message: "Node restriction, virt-handler is not allowed to set target node",
+					},
+				})
+			}
+		} else {
+			return webhookutils.ToAdmissionResponse([]metav1.StatusCause{
+				{
+					Type:    metav1.CauseTypeFieldValueInvalid,
+					Message: "Node restriction failed, virt-handler service account is missing node name",
+				},
+			})
+		}
+	}
+
 	// Reject VMI update if VMI spec changed
 	if !equality.Semantic.DeepEqual(newVMI.Spec, oldVMI.Spec) {
 		// Only allow the KubeVirt SA to modify the VMI spec, since that means it went through the sub resource.
diff --git a/pkg/virt-api/webhooks/validating-webhook/admitters/vmi-update-admitter_test.go b/pkg/virt-api/webhooks/validating-webhook/admitters/vmi-update-admitter_test.go
index a12cd35a4207..edfe94022436 100644
--- a/pkg/virt-api/webhooks/validating-webhook/admitters/vmi-update-admitter_test.go
+++ b/pkg/virt-api/webhooks/validating-webhook/admitters/vmi-update-admitter_test.go
@@ -25,6 +25,7 @@ import (
 
 	. "github.com/onsi/ginkgo/v2"
 	. "github.com/onsi/gomega"
+	"github.com/onsi/gomega/gstruct"
 	"github.com/onsi/gomega/types"
 	admissionv1 "k8s.io/api/admission/v1"
 	authv1 "k8s.io/api/authentication/v1"
@@ -76,6 +77,161 @@ var _ = Describe("Validating VMIUpdate Admitter", func() {
 	config, _, _ := testutils.NewFakeClusterConfigUsingKV(kv)
 	vmiUpdateAdmitter := &VMIUpdateAdmitter{config}
 
+	Context("Node restriction", func() {
+		mustMarshal := func(vmi *v1.VirtualMachineInstance) []byte {
+			b, err := json.Marshal(vmi)
+			Expect(err).To(Not(HaveOccurred()))
+			return b
+		}
+
+		admissionWithCustomUpdate := func(vmi, updatedVMI *v1.VirtualMachineInstance, handlernode string) *admissionv1.AdmissionReview {
+			newVMIBytes := mustMarshal(updatedVMI)
+			oldVMIBytes := mustMarshal(vmi)
+			return &admissionv1.AdmissionReview{
+				Request: &admissionv1.AdmissionRequest{
+					UserInfo: authv1.UserInfo{
+						Username: "system:serviceaccount:kubevirt:kubevirt-handler",
+						Extra: map[string]authv1.ExtraValue{
+							"authentication.kubernetes.io/node-name": {handlernode},
+						},
+					},
+					Resource: webhooks.VirtualMachineInstanceGroupVersionResource,
+					Object: runtime.RawExtension{
+						Raw: newVMIBytes,
+					},
+					OldObject: runtime.RawExtension{
+						Raw: oldVMIBytes,
+					},
+					Operation: admissionv1.Update,
+				},
+			}
+		}
+
+		admission := func(vmi *v1.VirtualMachineInstance, handlernode string) *admissionv1.AdmissionReview {
+			updatedVMI := vmi.DeepCopy()
+			if updatedVMI.Labels == nil {
+				updatedVMI.Labels = map[string]string{}
+			}
+			updatedVMI.Labels["allowed.io"] = "value"
+			return admissionWithCustomUpdate(vmi, updatedVMI, handlernode)
+		}
+
+		Context("with Node Restriction feature gate enabled", func() {
+			BeforeEach(func() { enableFeatureGate(virtconfig.NodeRestrictionGate) })
+
+			shouldNotAllowCrossNodeRequest := And(
+				WithTransform(func(resp *admissionv1.AdmissionResponse) bool { return resp.Allowed },
+					BeFalse(),
+				),
+				WithTransform(func(resp *admissionv1.AdmissionResponse) []metav1.StatusCause { return resp.Result.Details.Causes },
+					ContainElement(
+						gstruct.MatchFields(gstruct.IgnoreExtras, gstruct.Fields{
+							"Message": Equal("Node restriction, virt-handler is only allowed to modify VMIs it owns"),
+						}),
+					),
+				),
+			)
+
+			shouldBeAllowed := WithTransform(func(resp *admissionv1.AdmissionResponse) bool { return resp.Allowed },
+				BeTrue(),
+			)
+
+			DescribeTable("and NodeName set", func(handlernode string, matcher types.GomegaMatcher) {
+				vmi := api.NewMinimalVMI("testvmi")
+				vmi.Status.NodeName = "got"
+
+				resp := vmiUpdateAdmitter.Admit(admission(vmi, handlernode))
+				Expect(resp).To(matcher)
+			},
+				Entry("should deny request if handler is on different node", "diff",
+					shouldNotAllowCrossNodeRequest,
+				),
+				Entry("should allow request if handler is on same node", "got",
+					shouldBeAllowed,
+				),
+			)
+
+			DescribeTable("and TargetNode set", func(handlernode string, matcher types.GomegaMatcher) {
+				vmi := api.NewMinimalVMI("testvmi")
+				vmi.Status.NodeName = "got"
+				vmi.Status.MigrationState = &v1.VirtualMachineInstanceMigrationState{
+					TargetNode: "git",
+				}
+
+				resp := vmiUpdateAdmitter.Admit(admission(vmi, handlernode))
+				Expect(resp).To(matcher)
+			},
+				Entry("should deny request if handler is on different node", "diff",
+					shouldNotAllowCrossNodeRequest,
+				),
+				Entry("should allow request if handler is on same node", "git",
+					shouldBeAllowed,
+				),
+			)
+
+			DescribeTable("and both NodeName and TargetNode set", func(handlernode string, matcher types.GomegaMatcher) {
+				vmi := api.NewMinimalVMI("testvmi")
+				vmi.Status.NodeName = "got"
+				vmi.Status.MigrationState = &v1.VirtualMachineInstanceMigrationState{
+					TargetNode: "target",
+				}
+
+				resp := vmiUpdateAdmitter.Admit(admission(vmi, handlernode))
+				Expect(resp).To(matcher)
+			},
+				Entry("should deny request if handler is on different node", "diff",
+					shouldNotAllowCrossNodeRequest,
+				),
+				Entry("should allow request if handler is on source node", "got",
+					shouldBeAllowed,
+				),
+
+				Entry("should allow request if handler is on target node", "target",
+					shouldBeAllowed,
+				),
+			)
+
+			It("should allow finalize migration", func() {
+				vmi := api.NewMinimalVMI("testvmi")
+				vmi.Status.NodeName = "got"
+				vmi.Status.MigrationState = &v1.VirtualMachineInstanceMigrationState{
+					TargetNode: "target",
+				}
+
+				updatedVMI := vmi.DeepCopy()
+				updatedVMI.Status.NodeName = "target"
+
+				resp := vmiUpdateAdmitter.Admit(admissionWithCustomUpdate(vmi, updatedVMI, "got"))
+				Expect(resp.Allowed).To(BeTrue())
+			})
+
+			It("should not allow to set targetNode to source handler", func() {
+				vmi := api.NewMinimalVMI("testvmi")
+				vmi.Status.NodeName = "got"
+
+				updatedVMI := vmi.DeepCopy()
+				updatedVMI.Status.MigrationState = &v1.VirtualMachineInstanceMigrationState{
+					TargetNode: "target",
+				}
+				resp := vmiUpdateAdmitter.Admit(admissionWithCustomUpdate(vmi, updatedVMI, "got"))
+				Expect(resp.Allowed).To(BeFalse())
+			})
+		})
+
+		DescribeTable("with Node Restriction feature gate disabled should allow different handler", func(migrationState *v1.VirtualMachineInstanceMigrationState) {
+			vmi := api.NewMinimalVMI("testvmi")
+			vmi.Status.NodeName = "got"
+			vmi.Status.MigrationState = migrationState
+
+			resp := vmiUpdateAdmitter.Admit(admission(vmi, "diff"))
+			Expect(resp.Allowed).To(BeTrue())
+		},
+			Entry("when TargetNode is not set", nil),
+			Entry("when TargetNode is set", &v1.VirtualMachineInstanceMigrationState{TargetNode: "git"}),
+		)
+
+	})
+
 	DescribeTable("should reject documents containing unknown or missing fields for", func(data string, validationResult string, gvr metav1.GroupVersionResource, review func(ar *admissionv1.AdmissionReview) *admissionv1.AdmissionResponse) {
 		input := map[string]interface{}{}
 		json.Unmarshal([]byte(data), &input)
diff --git a/pkg/virt-config/feature-gates.go b/pkg/virt-config/feature-gates.go
index f1b7ecfb2ad2..71551da7de7b 100644
--- a/pkg/virt-config/feature-gates.go
+++ b/pkg/virt-config/feature-gates.go
@@ -85,6 +85,13 @@ const (
 	// KubevirtSeccompProfile indicate that Kubevirt will install its custom profile and
 	// user can tell Kubevirt to use it
 	KubevirtSeccompProfile = "KubevirtSeccompProfile"
+	// Owner: @xpivarc
+	// Alpha: v1.3.0
+	//
+	// NodeRestriction enables Kubelet's like NodeRestriction but for Kubevirt's virt-handler.
+	// This feature requires following Kubernetes feature gate "ServiceAccountTokenPodNodeInfo". The feature gate is available
+	// in Kubernetes 1.30 as Beta.
+	NodeRestrictionGate = "NodeRestriction"
 )
 
 var deprecatedFeatureGates = [...]string{
@@ -256,3 +263,7 @@ func (config *ClusterConfig) VolumesUpdateStrategyEnabled() bool {
 func (config *ClusterConfig) KubevirtSeccompProfileEnabled() bool {
 	return config.isFeatureGateEnabled(KubevirtSeccompProfile)
 }
+
+func (config *ClusterConfig) NodeRestrictionEnabled() bool {
+	return config.isFeatureGateEnabled(NodeRestrictionGate)
+}
diff --git a/tests/decorators/decorators.go b/tests/decorators/decorators.go
index 6f728b176c0e..a39c77f569b7 100644
--- a/tests/decorators/decorators.go
+++ b/tests/decorators/decorators.go
@@ -56,4 +56,7 @@ var (
 	Upgrade          = []interface{}{Label("Upgrade")}
 	CustomSELinux    = []interface{}{Label("CustomSELinux")}
 	Istio            = []interface{}{Label("Istio")}
+
+	// Kubernetes versions
+	Kubernetes130 = []interface{}{Label("kubernetes130")}
 )
From d1d26f9cba0decb69e3e610971ed70edba53d906 Mon Sep 17 00:00:00 2001
From: Luboslav Pivarc <lpivarc@redhat.com>
Date: Tue, 11 Jun 2024 13:47:46 +0200
Subject: [PATCH 3/3] Run NodeIsolation tests only on 1.30 lane

Signed-off-by: Luboslav Pivarc <lpivarc@redhat.com>
---
 automation/test.sh | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/automation/test.sh b/automation/test.sh
index b3bf13dacc55..4ea306a710bf 100755
--- a/automation/test.sh
+++ b/automation/test.sh
@@ -455,6 +455,10 @@ if [[ -z ${KUBEVIRT_E2E_FOCUS} && -z ${KUBEVIRT_E2E_SKIP} && -z ${label_filter}
   else
     label_filter='(!(Multus,SRIOV,Macvtap,GPU,VGPU))'
   fi
+
+  if [[ ! $TARGET =~ k8s-1\.3[0-9].* ]]; then
+    add_to_label_filter "(!kubernetes130)" "&&"
+  fi
 fi
 
 add_to_label_filter() {
